/* automatically generated by rust-bindgen */

pub const _opusfile_h: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const INCLUDE_INTTYPES_H: u32 = 1;
pub const INCLUDE_STDINT_H: u32 = 1;
pub const INCLUDE_SYS_TYPES_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const OPUS_OK: u32 = 0;
pub const OPUS_BAD_ARG: i32 = -1;
pub const OPUS_BUFFER_TOO_SMALL: i32 = -2;
pub const OPUS_INTERNAL_ERROR: i32 = -3;
pub const OPUS_INVALID_PACKET: i32 = -4;
pub const OPUS_UNIMPLEMENTED: i32 = -5;
pub const OPUS_INVALID_STATE: i32 = -6;
pub const OPUS_ALLOC_FAIL: i32 = -7;
pub const OPUS_SET_APPLICATION_REQUEST: u32 = 4000;
pub const OPUS_GET_APPLICATION_REQUEST: u32 = 4001;
pub const OPUS_SET_BITRATE_REQUEST: u32 = 4002;
pub const OPUS_GET_BITRATE_REQUEST: u32 = 4003;
pub const OPUS_SET_MAX_BANDWIDTH_REQUEST: u32 = 4004;
pub const OPUS_GET_MAX_BANDWIDTH_REQUEST: u32 = 4005;
pub const OPUS_SET_VBR_REQUEST: u32 = 4006;
pub const OPUS_GET_VBR_REQUEST: u32 = 4007;
pub const OPUS_SET_BANDWIDTH_REQUEST: u32 = 4008;
pub const OPUS_GET_BANDWIDTH_REQUEST: u32 = 4009;
pub const OPUS_SET_COMPLEXITY_REQUEST: u32 = 4010;
pub const OPUS_GET_COMPLEXITY_REQUEST: u32 = 4011;
pub const OPUS_SET_INBAND_FEC_REQUEST: u32 = 4012;
pub const OPUS_GET_INBAND_FEC_REQUEST: u32 = 4013;
pub const OPUS_SET_PACKET_LOSS_PERC_REQUEST: u32 = 4014;
pub const OPUS_GET_PACKET_LOSS_PERC_REQUEST: u32 = 4015;
pub const OPUS_SET_DTX_REQUEST: u32 = 4016;
pub const OPUS_GET_DTX_REQUEST: u32 = 4017;
pub const OPUS_SET_VBR_CONSTRAINT_REQUEST: u32 = 4020;
pub const OPUS_GET_VBR_CONSTRAINT_REQUEST: u32 = 4021;
pub const OPUS_SET_FORCE_CHANNELS_REQUEST: u32 = 4022;
pub const OPUS_GET_FORCE_CHANNELS_REQUEST: u32 = 4023;
pub const OPUS_SET_SIGNAL_REQUEST: u32 = 4024;
pub const OPUS_GET_SIGNAL_REQUEST: u32 = 4025;
pub const OPUS_GET_LOOKAHEAD_REQUEST: u32 = 4027;
pub const OPUS_GET_SAMPLE_RATE_REQUEST: u32 = 4029;
pub const OPUS_GET_FINAL_RANGE_REQUEST: u32 = 4031;
pub const OPUS_GET_PITCH_REQUEST: u32 = 4033;
pub const OPUS_SET_GAIN_REQUEST: u32 = 4034;
pub const OPUS_GET_GAIN_REQUEST: u32 = 4045;
pub const OPUS_SET_LSB_DEPTH_REQUEST: u32 = 4036;
pub const OPUS_GET_LSB_DEPTH_REQUEST: u32 = 4037;
pub const OPUS_GET_LAST_PACKET_DURATION_REQUEST: u32 = 4039;
pub const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4040;
pub const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4041;
pub const OPUS_SET_PREDICTION_DISABLED_REQUEST: u32 = 4042;
pub const OPUS_GET_PREDICTION_DISABLED_REQUEST: u32 = 4043;
pub const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4046;
pub const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4047;
pub const OPUS_GET_IN_DTX_REQUEST: u32 = 4049;
pub const OPUS_AUTO: i32 = -1000;
pub const OPUS_BITRATE_MAX: i32 = -1;
pub const OPUS_APPLICATION_VOIP: u32 = 2048;
pub const OPUS_APPLICATION_AUDIO: u32 = 2049;
pub const OPUS_APPLICATION_RESTRICTED_LOWDELAY: u32 = 2051;
pub const OPUS_SIGNAL_VOICE: u32 = 3001;
pub const OPUS_SIGNAL_MUSIC: u32 = 3002;
pub const OPUS_BANDWIDTH_NARROWBAND: u32 = 1101;
pub const OPUS_BANDWIDTH_MEDIUMBAND: u32 = 1102;
pub const OPUS_BANDWIDTH_WIDEBAND: u32 = 1103;
pub const OPUS_BANDWIDTH_SUPERWIDEBAND: u32 = 1104;
pub const OPUS_BANDWIDTH_FULLBAND: u32 = 1105;
pub const OPUS_FRAMESIZE_ARG: u32 = 5000;
pub const OPUS_FRAMESIZE_2_5_MS: u32 = 5001;
pub const OPUS_FRAMESIZE_5_MS: u32 = 5002;
pub const OPUS_FRAMESIZE_10_MS: u32 = 5003;
pub const OPUS_FRAMESIZE_20_MS: u32 = 5004;
pub const OPUS_FRAMESIZE_40_MS: u32 = 5005;
pub const OPUS_FRAMESIZE_60_MS: u32 = 5006;
pub const OPUS_FRAMESIZE_80_MS: u32 = 5007;
pub const OPUS_FRAMESIZE_100_MS: u32 = 5008;
pub const OPUS_FRAMESIZE_120_MS: u32 = 5009;
pub const OPUS_RESET_STATE: u32 = 4028;
pub const OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST: u32 = 5120;
pub const OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST: u32 = 5122;
pub const OP_FALSE: i32 = -1;
pub const OP_EOF: i32 = -2;
pub const OP_HOLE: i32 = -3;
pub const OP_EREAD: i32 = -128;
pub const OP_EFAULT: i32 = -129;
pub const OP_EIMPL: i32 = -130;
pub const OP_EINVAL: i32 = -131;
pub const OP_ENOTFORMAT: i32 = -132;
pub const OP_EBADHEADER: i32 = -133;
pub const OP_EVERSION: i32 = -134;
pub const OP_ENOTAUDIO: i32 = -135;
pub const OP_EBADPACKET: i32 = -136;
pub const OP_EBADLINK: i32 = -137;
pub const OP_ENOSEEK: i32 = -138;
pub const OP_EBADTIMESTAMP: i32 = -139;
pub const OPUS_CHANNEL_COUNT_MAX: u32 = 255;
pub const OP_PIC_FORMAT_UNKNOWN: i32 = -1;
pub const OP_PIC_FORMAT_URL: u32 = 0;
pub const OP_PIC_FORMAT_JPEG: u32 = 1;
pub const OP_PIC_FORMAT_PNG: u32 = 2;
pub const OP_PIC_FORMAT_GIF: u32 = 3;
pub const OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST: u32 = 6464;
pub const OP_HTTP_PROXY_HOST_REQUEST: u32 = 6528;
pub const OP_HTTP_PROXY_PORT_REQUEST: u32 = 6592;
pub const OP_HTTP_PROXY_USER_REQUEST: u32 = 6656;
pub const OP_HTTP_PROXY_PASS_REQUEST: u32 = 6720;
pub const OP_GET_SERVER_INFO_REQUEST: u32 = 6784;
pub const OP_DEC_FORMAT_SHORT: u32 = 7008;
pub const OP_DEC_FORMAT_FLOAT: u32 = 7040;
pub const OP_DEC_USE_DEFAULT: u32 = 6720;
pub const OP_HEADER_GAIN: u32 = 0;
pub const OP_ALBUM_GAIN: u32 = 3007;
pub const OP_TRACK_GAIN: u32 = 3008;
pub const OP_ABSOLUTE_GAIN: u32 = 3009;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type ogg_int16_t = i16;
pub type ogg_uint16_t = u16;
pub type ogg_int32_t = i32;
pub type ogg_uint32_t = u32;
pub type ogg_int64_t = i64;
pub type ogg_uint64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_iovec_t {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_ogg_iovec_t() {
    assert_eq!(
        ::std::mem::size_of::<ogg_iovec_t>(),
        16usize,
        concat!("Size of: ", stringify!(ogg_iovec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_iovec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_iovec_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_iovec_t>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_iovec_t),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_iovec_t>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_iovec_t),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oggpack_buffer {
    pub endbyte: ::std::os::raw::c_long,
    pub endbit: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub ptr: *mut ::std::os::raw::c_uchar,
    pub storage: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_oggpack_buffer() {
    assert_eq!(
        ::std::mem::size_of::<oggpack_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(oggpack_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<oggpack_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(oggpack_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oggpack_buffer>())).endbyte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(endbyte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oggpack_buffer>())).endbit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(endbit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oggpack_buffer>())).buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oggpack_buffer>())).ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oggpack_buffer>())).storage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(storage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_page {
    pub header: *mut ::std::os::raw::c_uchar,
    pub header_len: ::std::os::raw::c_long,
    pub body: *mut ::std::os::raw::c_uchar,
    pub body_len: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ogg_page() {
    assert_eq!(
        ::std::mem::size_of::<ogg_page>(),
        32usize,
        concat!("Size of: ", stringify!(ogg_page))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_page>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_page>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_page>())).header_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(header_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_page>())).body as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_page>())).body_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(body_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ogg_stream_state {
    pub body_data: *mut ::std::os::raw::c_uchar,
    pub body_storage: ::std::os::raw::c_long,
    pub body_fill: ::std::os::raw::c_long,
    pub body_returned: ::std::os::raw::c_long,
    pub lacing_vals: *mut ::std::os::raw::c_int,
    pub granule_vals: *mut ogg_int64_t,
    pub lacing_storage: ::std::os::raw::c_long,
    pub lacing_fill: ::std::os::raw::c_long,
    pub lacing_packet: ::std::os::raw::c_long,
    pub lacing_returned: ::std::os::raw::c_long,
    pub header: [::std::os::raw::c_uchar; 282usize],
    pub header_fill: ::std::os::raw::c_int,
    pub e_o_s: ::std::os::raw::c_int,
    pub b_o_s: ::std::os::raw::c_int,
    pub serialno: ::std::os::raw::c_long,
    pub pageno: ::std::os::raw::c_long,
    pub packetno: ogg_int64_t,
    pub granulepos: ogg_int64_t,
}
#[test]
fn bindgen_test_layout_ogg_stream_state() {
    assert_eq!(
        ::std::mem::size_of::<ogg_stream_state>(),
        408usize,
        concat!("Size of: ", stringify!(ogg_stream_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_stream_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_stream_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).body_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).body_storage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).body_fill as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).body_returned as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_returned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).lacing_vals as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_vals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).granule_vals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(granule_vals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).lacing_storage as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).lacing_fill as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).lacing_packet as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_packet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ogg_stream_state>())).lacing_returned as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_returned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).header as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).header_fill as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(header_fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).e_o_s as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(e_o_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).b_o_s as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(b_o_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).serialno as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(serialno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).pageno as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(pageno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).packetno as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(packetno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_stream_state>())).granulepos as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(granulepos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_packet {
    pub packet: *mut ::std::os::raw::c_uchar,
    pub bytes: ::std::os::raw::c_long,
    pub b_o_s: ::std::os::raw::c_long,
    pub e_o_s: ::std::os::raw::c_long,
    pub granulepos: ogg_int64_t,
    pub packetno: ogg_int64_t,
}
#[test]
fn bindgen_test_layout_ogg_packet() {
    assert_eq!(
        ::std::mem::size_of::<ogg_packet>(),
        48usize,
        concat!("Size of: ", stringify!(ogg_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_packet>())).packet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_packet>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_packet>())).b_o_s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(b_o_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_packet>())).e_o_s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(e_o_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_packet>())).granulepos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(granulepos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_packet>())).packetno as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(packetno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_sync_state {
    pub data: *mut ::std::os::raw::c_uchar,
    pub storage: ::std::os::raw::c_int,
    pub fill: ::std::os::raw::c_int,
    pub returned: ::std::os::raw::c_int,
    pub unsynced: ::std::os::raw::c_int,
    pub headerbytes: ::std::os::raw::c_int,
    pub bodybytes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ogg_sync_state() {
    assert_eq!(
        ::std::mem::size_of::<ogg_sync_state>(),
        32usize,
        concat!("Size of: ", stringify!(ogg_sync_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_sync_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_sync_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).storage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).fill as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).returned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(returned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).unsynced as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(unsynced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).headerbytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(headerbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ogg_sync_state>())).bodybytes as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(bodybytes)
        )
    );
}
extern "C" {
    pub fn oggpack_writeinit(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_writecheck(b: *mut oggpack_buffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn oggpack_writetrunc(b: *mut oggpack_buffer, bits: ::std::os::raw::c_long);
}
extern "C" {
    pub fn oggpack_writealign(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_writecopy(
        b: *mut oggpack_buffer,
        source: *mut ::std::os::raw::c_void,
        bits: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn oggpack_reset(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_writeclear(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_readinit(
        b: *mut oggpack_buffer,
        buf: *mut ::std::os::raw::c_uchar,
        bytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpack_write(
        b: *mut oggpack_buffer,
        value: ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpack_look(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_look1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_adv(b: *mut oggpack_buffer, bits: ::std::os::raw::c_int);
}
extern "C" {
    pub fn oggpack_adv1(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_read(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_read1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_bytes(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_bits(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_get_buffer(b: *mut oggpack_buffer) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn oggpackB_writeinit(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_writecheck(b: *mut oggpack_buffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn oggpackB_writetrunc(b: *mut oggpack_buffer, bits: ::std::os::raw::c_long);
}
extern "C" {
    pub fn oggpackB_writealign(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_writecopy(
        b: *mut oggpack_buffer,
        source: *mut ::std::os::raw::c_void,
        bits: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn oggpackB_reset(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_writeclear(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_readinit(
        b: *mut oggpack_buffer,
        buf: *mut ::std::os::raw::c_uchar,
        bytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpackB_write(
        b: *mut oggpack_buffer,
        value: ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpackB_look(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_look1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_adv(b: *mut oggpack_buffer, bits: ::std::os::raw::c_int);
}
extern "C" {
    pub fn oggpackB_adv1(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_read(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_read1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_bytes(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_bits(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_get_buffer(b: *mut oggpack_buffer) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ogg_stream_packetin(
        os: *mut ogg_stream_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_iovecin(
        os: *mut ogg_stream_state,
        iov: *mut ogg_iovec_t,
        count: ::std::os::raw::c_int,
        e_o_s: ::std::os::raw::c_long,
        granulepos: ogg_int64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_pageout(
        os: *mut ogg_stream_state,
        og: *mut ogg_page,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_pageout_fill(
        os: *mut ogg_stream_state,
        og: *mut ogg_page,
        nfill: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_flush(os: *mut ogg_stream_state, og: *mut ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_flush_fill(
        os: *mut ogg_stream_state,
        og: *mut ogg_page,
        nfill: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_init(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_clear(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_reset(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_destroy(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_check(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_buffer(
        oy: *mut ogg_sync_state,
        size: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ogg_sync_wrote(
        oy: *mut ogg_sync_state,
        bytes: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_pageseek(oy: *mut ogg_sync_state, og: *mut ogg_page) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ogg_sync_pageout(oy: *mut ogg_sync_state, og: *mut ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_pagein(os: *mut ogg_stream_state, og: *mut ogg_page)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_packetout(
        os: *mut ogg_stream_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_packetpeek(
        os: *mut ogg_stream_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_init(
        os: *mut ogg_stream_state,
        serialno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_clear(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_reset(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_reset_serialno(
        os: *mut ogg_stream_state,
        serialno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_destroy(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_check(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_eos(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_checksum_set(og: *mut ogg_page);
}
extern "C" {
    pub fn ogg_page_version(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_continued(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_bos(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_eos(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_granulepos(og: *const ogg_page) -> ogg_int64_t;
}
extern "C" {
    pub fn ogg_page_serialno(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_pageno(og: *const ogg_page) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ogg_page_packets(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_packet_clear(op: *mut ogg_packet);
}
pub type opus_int8 = i8;
pub type opus_uint8 = u8;
pub type opus_int16 = i16;
pub type opus_uint16 = u16;
pub type opus_int32 = i32;
pub type opus_uint32 = u32;
pub type opus_int64 = i64;
pub type opus_uint64 = u64;
extern "C" {
    #[doc = " Converts an opus error code into a human readable string."]
    #[doc = ""]
    #[doc = " @param[in] error <tt>int</tt>: Error number"]
    #[doc = " @returns Error string"]
    pub fn opus_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the libopus version string."]
    #[doc = ""]
    #[doc = " Applications may look for the substring \"-fixed\" in the version string to"]
    #[doc = " determine whether they have a fixed-point or floating-point build at"]
    #[doc = " runtime."]
    #[doc = ""]
    #[doc = " @returns Version string"]
    pub fn opus_get_version_string() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusEncoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusEncoder</code> structure."]
    #[doc = " @param[in] channels <tt>int</tt>: Number of channels."]
    #[doc = "                                   This must be 1 or 2."]
    #[doc = " @returns The size in bytes."]
    pub fn opus_encoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates and initializes an encoder state."]
    #[doc = " There are three coding modes:"]
    #[doc = ""]
    #[doc = " @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice"]
    #[doc = "    signals. It enhances the  input signal by high-pass filtering and"]
    #[doc = "    emphasizing formants and harmonics. Optionally  it includes in-band"]
    #[doc = "    forward error correction to protect against packet loss. Use this"]
    #[doc = "    mode for typical VoIP applications. Because of the enhancement,"]
    #[doc = "    even at high bitrates the output may sound different from the input."]
    #[doc = ""]
    #[doc = " @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most"]
    #[doc = "    non-voice signals like music. Use this mode for music and mixed"]
    #[doc = "    (music/voice) content, broadcast, and applications requiring less"]
    #[doc = "    than 15 ms of coding delay."]
    #[doc = ""]
    #[doc = " @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that"]
    #[doc = "    disables the speech-optimized mode in exchange for slightly reduced delay."]
    #[doc = "    This mode can only be set on an newly initialized or freshly reset encoder"]
    #[doc = "    because it changes the codec delay."]
    #[doc = ""]
    #[doc = " This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution)."]
    #[doc = " @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)"]
    #[doc = "                                     This must be one of 8000, 12000, 16000,"]
    #[doc = "                                     24000, or 48000."]
    #[doc = " @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal"]
    #[doc = " @param [in] application <tt>int</tt>: Coding mode (@ref OPUS_APPLICATION_VOIP/@ref OPUS_APPLICATION_AUDIO/@ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)"]
    #[doc = " @param [out] error <tt>int*</tt>: @ref opus_errorcodes"]
    #[doc = " @note Regardless of the sampling rate and number channels selected, the Opus encoder"]
    #[doc = " can switch to a lower audio bandwidth or number of channels if the bitrate"]
    #[doc = " selected is too low. This also means that it is safe to always use 48 kHz stereo input"]
    #[doc = " and let the encoder optimize the encoding."]
    pub fn opus_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusEncoder;
}
extern "C" {
    #[doc = " Initializes a previously allocated encoder state"]
    #[doc = " The memory pointed to by st must be at least the size returned by opus_encoder_get_size()."]
    #[doc = " This is intended for applications which use their own allocator instead of malloc."]
    #[doc = " @see opus_encoder_create(),opus_encoder_get_size()"]
    #[doc = " To reset a previously initialized state, use the #OPUS_RESET_STATE CTL."]
    #[doc = " @param [in] st <tt>OpusEncoder*</tt>: Encoder state"]
    #[doc = " @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)"]
    #[doc = "                                      This must be one of 8000, 12000, 16000,"]
    #[doc = "                                      24000, or 48000."]
    #[doc = " @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal"]
    #[doc = " @param [in] application <tt>int</tt>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY)"]
    #[doc = " @retval #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_encoder_init(
        st: *mut OpusEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes an Opus frame."]
    #[doc = " @param [in] st <tt>OpusEncoder*</tt>: Encoder state"]
    #[doc = " @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)"]
    #[doc = " @param [in] frame_size <tt>int</tt>: Number of samples per channel in the"]
    #[doc = "                                      input signal."]
    #[doc = "                                      This must be an Opus frame size for"]
    #[doc = "                                      the encoder's sampling rate."]
    #[doc = "                                      For example, at 48 kHz the permitted"]
    #[doc = "                                      values are 120, 240, 480, 960, 1920,"]
    #[doc = "                                      and 2880."]
    #[doc = "                                      Passing in a duration of less than"]
    #[doc = "                                      10 ms (480 samples at 48 kHz) will"]
    #[doc = "                                      prevent the encoder from using the LPC"]
    #[doc = "                                      or hybrid modes."]
    #[doc = " @param [out] data <tt>unsigned char*</tt>: Output payload."]
    #[doc = "                                            This must contain storage for at"]
    #[doc = "                                            least \\a max_data_bytes."]
    #[doc = " @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated"]
    #[doc = "                                                 memory for the output"]
    #[doc = "                                                 payload. This may be"]
    #[doc = "                                                 used to impose an upper limit on"]
    #[doc = "                                                 the instant bitrate, but should"]
    #[doc = "                                                 not be used as the only bitrate"]
    #[doc = "                                                 control. Use #OPUS_SET_BITRATE to"]
    #[doc = "                                                 control the bitrate."]
    #[doc = " @returns The length of the encoded packet (in bytes) on success or a"]
    #[doc = "          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode(
        st: *mut OpusEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Encodes an Opus frame from floating point input."]
    #[doc = " @param [in] st <tt>OpusEncoder*</tt>: Encoder state"]
    #[doc = " @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0."]
    #[doc = "          Samples with a range beyond +/-1.0 are supported but will"]
    #[doc = "          be clipped by decoders using the integer API and should"]
    #[doc = "          only be used if it is known that the far end supports"]
    #[doc = "          extended dynamic range."]
    #[doc = "          length is frame_size*channels*sizeof(float)"]
    #[doc = " @param [in] frame_size <tt>int</tt>: Number of samples per channel in the"]
    #[doc = "                                      input signal."]
    #[doc = "                                      This must be an Opus frame size for"]
    #[doc = "                                      the encoder's sampling rate."]
    #[doc = "                                      For example, at 48 kHz the permitted"]
    #[doc = "                                      values are 120, 240, 480, 960, 1920,"]
    #[doc = "                                      and 2880."]
    #[doc = "                                      Passing in a duration of less than"]
    #[doc = "                                      10 ms (480 samples at 48 kHz) will"]
    #[doc = "                                      prevent the encoder from using the LPC"]
    #[doc = "                                      or hybrid modes."]
    #[doc = " @param [out] data <tt>unsigned char*</tt>: Output payload."]
    #[doc = "                                            This must contain storage for at"]
    #[doc = "                                            least \\a max_data_bytes."]
    #[doc = " @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated"]
    #[doc = "                                                 memory for the output"]
    #[doc = "                                                 payload. This may be"]
    #[doc = "                                                 used to impose an upper limit on"]
    #[doc = "                                                 the instant bitrate, but should"]
    #[doc = "                                                 not be used as the only bitrate"]
    #[doc = "                                                 control. Use #OPUS_SET_BITRATE to"]
    #[doc = "                                                 control the bitrate."]
    #[doc = " @returns The length of the encoded packet (in bytes) on success or a"]
    #[doc = "          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode_float(
        st: *mut OpusEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Frees an <code>OpusEncoder</code> allocated by opus_encoder_create()."]
    #[doc = " @param[in] st <tt>OpusEncoder*</tt>: State to be freed."]
    pub fn opus_encoder_destroy(st: *mut OpusEncoder);
}
extern "C" {
    #[doc = " Perform a CTL function on an Opus encoder."]
    #[doc = ""]
    #[doc = " Generally the request and subsequent arguments are generated"]
    #[doc = " by a convenience macro."]
    #[doc = " @param st <tt>OpusEncoder*</tt>: Encoder state."]
    #[doc = " @param request This and all remaining parameters should be replaced by one"]
    #[doc = "                of the convenience macros in @ref opus_genericctls or"]
    #[doc = "                @ref opus_encoderctls."]
    #[doc = " @see opus_genericctls"]
    #[doc = " @see opus_encoderctls"]
    pub fn opus_encoder_ctl(
        st: *mut OpusEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDecoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusDecoder</code> structure."]
    #[doc = " @param [in] channels <tt>int</tt>: Number of channels."]
    #[doc = "                                    This must be 1 or 2."]
    #[doc = " @returns The size in bytes."]
    pub fn opus_decoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates and initializes a decoder state."]
    #[doc = " @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz)."]
    #[doc = "                                     This must be one of 8000, 12000, 16000,"]
    #[doc = "                                     24000, or 48000."]
    #[doc = " @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode"]
    #[doc = " @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes"]
    #[doc = ""]
    #[doc = " Internally Opus stores data at 48000 Hz, so that should be the default"]
    #[doc = " value for Fs. However, the decoder can efficiently decode to buffers"]
    #[doc = " at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use"]
    #[doc = " data at the full sample rate, or knows the compressed data doesn't"]
    #[doc = " use the full frequency range, it can request decoding at a reduced"]
    #[doc = " rate. Likewise, the decoder is capable of filling in either mono or"]
    #[doc = " interleaved stereo pcm buffers, at the caller's request."]
    pub fn opus_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusDecoder;
}
extern "C" {
    #[doc = " Initializes a previously allocated decoder state."]
    #[doc = " The state must be at least the size returned by opus_decoder_get_size()."]
    #[doc = " This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size"]
    #[doc = " To reset a previously initialized state, use the #OPUS_RESET_STATE CTL."]
    #[doc = " @param [in] st <tt>OpusDecoder*</tt>: Decoder state."]
    #[doc = " @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz)."]
    #[doc = "                                     This must be one of 8000, 12000, 16000,"]
    #[doc = "                                     24000, or 48000."]
    #[doc = " @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode"]
    #[doc = " @retval #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_decoder_init(
        st: *mut OpusDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode an Opus packet."]
    #[doc = " @param [in] st <tt>OpusDecoder*</tt>: Decoder state"]
    #[doc = " @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss"]
    #[doc = " @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*"]
    #[doc = " @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length"]
    #[doc = "  is frame_size*channels*sizeof(opus_int16)"]
    #[doc = " @param [in] frame_size Number of samples per channel of available space in \\a pcm."]
    #[doc = "  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will"]
    #[doc = "  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),"]
    #[doc = "  then frame_size needs to be exactly the duration of audio that is missing, otherwise the"]
    #[doc = "  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and"]
    #[doc = "  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms."]
    #[doc = " @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be"]
    #[doc = "  decoded. If no such data is available, the frame is decoded as if it were lost."]
    #[doc = " @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decode(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode an Opus packet with floating point output."]
    #[doc = " @param [in] st <tt>OpusDecoder*</tt>: Decoder state"]
    #[doc = " @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss"]
    #[doc = " @param [in] len <tt>opus_int32</tt>: Number of bytes in payload"]
    #[doc = " @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length"]
    #[doc = "  is frame_size*channels*sizeof(float)"]
    #[doc = " @param [in] frame_size Number of samples per channel of available space in \\a pcm."]
    #[doc = "  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will"]
    #[doc = "  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),"]
    #[doc = "  then frame_size needs to be exactly the duration of audio that is missing, otherwise the"]
    #[doc = "  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and"]
    #[doc = "  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms."]
    #[doc = " @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be"]
    #[doc = "  decoded. If no such data is available the frame is decoded as if it were lost."]
    #[doc = " @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decode_float(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a CTL function on an Opus decoder."]
    #[doc = ""]
    #[doc = " Generally the request and subsequent arguments are generated"]
    #[doc = " by a convenience macro."]
    #[doc = " @param st <tt>OpusDecoder*</tt>: Decoder state."]
    #[doc = " @param request This and all remaining parameters should be replaced by one"]
    #[doc = "                of the convenience macros in @ref opus_genericctls or"]
    #[doc = "                @ref opus_decoderctls."]
    #[doc = " @see opus_genericctls"]
    #[doc = " @see opus_decoderctls"]
    pub fn opus_decoder_ctl(
        st: *mut OpusDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees an <code>OpusDecoder</code> allocated by opus_decoder_create()."]
    #[doc = " @param[in] st <tt>OpusDecoder*</tt>: State to be freed."]
    pub fn opus_decoder_destroy(st: *mut OpusDecoder);
}
extern "C" {
    #[doc = " Parse an opus packet into one or more frames."]
    #[doc = " Opus_decode will perform this operation internally so most applications do"]
    #[doc = " not need to use this function."]
    #[doc = " This function does not copy the frames, the returned pointers are pointers into"]
    #[doc = " the input packet."]
    #[doc = " @param [in] data <tt>char*</tt>: Opus packet to be parsed"]
    #[doc = " @param [in] len <tt>opus_int32</tt>: size of data"]
    #[doc = " @param [out] out_toc <tt>char*</tt>: TOC pointer"]
    #[doc = " @param [out] frames <tt>char*[48]</tt> encapsulated frames"]
    #[doc = " @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames"]
    #[doc = " @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)"]
    #[doc = " @returns number of frames"]
    pub fn opus_packet_parse(
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        out_toc: *mut ::std::os::raw::c_uchar,
        frames: *mut *const ::std::os::raw::c_uchar,
        size: *mut opus_int16,
        payload_offset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the bandwidth of an Opus packet."]
    #[doc = " @param [in] data <tt>char*</tt>: Opus packet"]
    #[doc = " @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)"]
    #[doc = " @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)"]
    #[doc = " @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)"]
    #[doc = " @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)"]
    #[doc = " @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)"]
    #[doc = " @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_bandwidth(data: *const ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of samples per frame from an Opus packet."]
    #[doc = " @param [in] data <tt>char*</tt>: Opus packet."]
    #[doc = "                                  This must contain at least one byte of"]
    #[doc = "                                  data."]
    #[doc = " @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz."]
    #[doc = "                                     This must be a multiple of 400, or"]
    #[doc = "                                     inaccurate results will be returned."]
    #[doc = " @returns Number of samples per frame."]
    pub fn opus_packet_get_samples_per_frame(
        data: *const ::std::os::raw::c_uchar,
        Fs: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of channels from an Opus packet."]
    #[doc = " @param [in] data <tt>char*</tt>: Opus packet"]
    #[doc = " @returns Number of channels"]
    #[doc = " @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_channels(
        data: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of frames in an Opus packet."]
    #[doc = " @param [in] packet <tt>char*</tt>: Opus packet"]
    #[doc = " @param [in] len <tt>opus_int32</tt>: Length of packet"]
    #[doc = " @returns Number of frames"]
    #[doc = " @retval OPUS_BAD_ARG Insufficient data was passed to the function"]
    #[doc = " @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_frames(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of samples of an Opus packet."]
    #[doc = " @param [in] packet <tt>char*</tt>: Opus packet"]
    #[doc = " @param [in] len <tt>opus_int32</tt>: Length of packet"]
    #[doc = " @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz."]
    #[doc = "                                     This must be a multiple of 400, or"]
    #[doc = "                                     inaccurate results will be returned."]
    #[doc = " @returns Number of samples"]
    #[doc = " @retval OPUS_BAD_ARG Insufficient data was passed to the function"]
    #[doc = " @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_samples(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        Fs: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of samples of an Opus packet."]
    #[doc = " @param [in] dec <tt>OpusDecoder*</tt>: Decoder state"]
    #[doc = " @param [in] packet <tt>char*</tt>: Opus packet"]
    #[doc = " @param [in] len <tt>opus_int32</tt>: Length of packet"]
    #[doc = " @returns Number of samples"]
    #[doc = " @retval OPUS_BAD_ARG Insufficient data was passed to the function"]
    #[doc = " @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_decoder_get_nb_samples(
        dec: *const OpusDecoder,
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Applies soft-clipping to bring a float signal within the [-1,1] range. If"]
    #[doc = " the signal is already in that range, nothing is done. If there are values"]
    #[doc = " outside of [-1,1], then the signal is clipped as smoothly as possible to"]
    #[doc = " both fit in the range and avoid creating excessive distortion in the"]
    #[doc = " process."]
    #[doc = " @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM"]
    #[doc = " @param [in] frame_size <tt>int</tt> Number of samples per channel to process"]
    #[doc = " @param [in] channels <tt>int</tt>: Number of channels"]
    #[doc = " @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)"]
    pub fn opus_pcm_soft_clip(
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        softclip_mem: *mut f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusRepacketizer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusRepacketizer</code> structure."]
    #[doc = " @returns The size in bytes."]
    pub fn opus_repacketizer_get_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " (Re)initializes a previously allocated repacketizer state."]
    #[doc = " The state must be at least the size returned by opus_repacketizer_get_size()."]
    #[doc = " This can be used for applications which use their own allocator instead of"]
    #[doc = " malloc()."]
    #[doc = " It must also be called to reset the queue of packets waiting to be"]
    #[doc = " repacketized, which is necessary if the maximum packet duration of 120 ms"]
    #[doc = " is reached or if you wish to submit packets with a different Opus"]
    #[doc = " configuration (coding mode, audio bandwidth, frame size, or channel count)."]
    #[doc = " Failure to do so will prevent a new packet from being added with"]
    #[doc = " opus_repacketizer_cat()."]
    #[doc = " @see opus_repacketizer_create"]
    #[doc = " @see opus_repacketizer_get_size"]
    #[doc = " @see opus_repacketizer_cat"]
    #[doc = " @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to"]
    #[doc = "                                       (re)initialize."]
    #[doc = " @returns A pointer to the same repacketizer state that was passed in."]
    pub fn opus_repacketizer_init(rp: *mut OpusRepacketizer) -> *mut OpusRepacketizer;
}
extern "C" {
    #[doc = " Allocates memory and initializes the new repacketizer with"]
    #[doc = " opus_repacketizer_init()."]
    pub fn opus_repacketizer_create() -> *mut OpusRepacketizer;
}
extern "C" {
    #[doc = " Frees an <code>OpusRepacketizer</code> allocated by"]
    #[doc = " opus_repacketizer_create()."]
    #[doc = " @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed."]
    pub fn opus_repacketizer_destroy(rp: *mut OpusRepacketizer);
}
extern "C" {
    #[doc = " Add a packet to the current repacketizer state."]
    #[doc = " This packet must match the configuration of any packets already submitted"]
    #[doc = " for repacketization since the last call to opus_repacketizer_init()."]
    #[doc = " This means that it must have the same coding mode, audio bandwidth, frame"]
    #[doc = " size, and channel count."]
    #[doc = " This can be checked in advance by examining the top 6 bits of the first"]
    #[doc = " byte of the packet, and ensuring they match the top 6 bits of the first"]
    #[doc = " byte of any previously submitted packet."]
    #[doc = " The total duration of audio in the repacketizer state also must not exceed"]
    #[doc = " 120 ms, the maximum duration of a single packet, after adding this packet."]
    #[doc = ""]
    #[doc = " The contents of the current repacketizer state can be extracted into new"]
    #[doc = " packets using opus_repacketizer_out() or opus_repacketizer_out_range()."]
    #[doc = ""]
    #[doc = " In order to add a packet with a different configuration or to add more"]
    #[doc = " audio beyond 120 ms, you must clear the repacketizer state by calling"]
    #[doc = " opus_repacketizer_init()."]
    #[doc = " If a packet is too large to add to the current repacketizer state, no part"]
    #[doc = " of it is added, even if it contains multiple frames, some of which might"]
    #[doc = " fit."]
    #[doc = " If you wish to be able to add parts of such packets, you should first use"]
    #[doc = " another repacketizer to split the packet into pieces and add them"]
    #[doc = " individually."]
    #[doc = " @see opus_repacketizer_out_range"]
    #[doc = " @see opus_repacketizer_out"]
    #[doc = " @see opus_repacketizer_init"]
    #[doc = " @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to"]
    #[doc = "                                       add the packet."]
    #[doc = " @param[in] data <tt>const unsigned char*</tt>: The packet data."]
    #[doc = "                                                The application must ensure"]
    #[doc = "                                                this pointer remains valid"]
    #[doc = "                                                until the next call to"]
    #[doc = "                                                opus_repacketizer_init() or"]
    #[doc = "                                                opus_repacketizer_destroy()."]
    #[doc = " @param len <tt>opus_int32</tt>: The number of bytes in the packet data."]
    #[doc = " @returns An error code indicating whether or not the operation succeeded."]
    #[doc = " @retval #OPUS_OK The packet's contents have been added to the repacketizer"]
    #[doc = "                  state."]
    #[doc = " @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,"]
    #[doc = "                              the packet's TOC sequence was not compatible"]
    #[doc = "                              with previously submitted packets (because"]
    #[doc = "                              the coding mode, audio bandwidth, frame size,"]
    #[doc = "                              or channel count did not match), or adding"]
    #[doc = "                              this packet would increase the total amount of"]
    #[doc = "                              audio stored in the repacketizer state to more"]
    #[doc = "                              than 120 ms."]
    pub fn opus_repacketizer_cat(
        rp: *mut OpusRepacketizer,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a new packet from data previously submitted to the repacketizer"]
    #[doc = " state via opus_repacketizer_cat()."]
    #[doc = " @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to"]
    #[doc = "                                       construct the new packet."]
    #[doc = " @param begin <tt>int</tt>: The index of the first frame in the current"]
    #[doc = "                            repacketizer state to include in the output."]
    #[doc = " @param end <tt>int</tt>: One past the index of the last frame in the"]
    #[doc = "                          current repacketizer state to include in the"]
    #[doc = "                          output."]
    #[doc = " @param[out] data <tt>const unsigned char*</tt>: The buffer in which to"]
    #[doc = "                                                 store the output packet."]
    #[doc = " @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in"]
    #[doc = "                                    the output buffer. In order to guarantee"]
    #[doc = "                                    success, this should be at least"]
    #[doc = "                                    <code>1276</code> for a single frame,"]
    #[doc = "                                    or for multiple frames,"]
    #[doc = "                                    <code>1277*(end-begin)</code>."]
    #[doc = "                                    However, <code>1*(end-begin)</code> plus"]
    #[doc = "                                    the size of all packet data submitted to"]
    #[doc = "                                    the repacketizer since the last call to"]
    #[doc = "                                    opus_repacketizer_init() or"]
    #[doc = "                                    opus_repacketizer_create() is also"]
    #[doc = "                                    sufficient, and possibly much smaller."]
    #[doc = " @returns The total size of the output packet on success, or an error code"]
    #[doc = "          on failure."]
    #[doc = " @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of"]
    #[doc = "                       frames (begin < 0, begin >= end, or end >"]
    #[doc = "                       opus_repacketizer_get_nb_frames())."]
    #[doc = " @retval #OPUS_BUFFER_TOO_SMALL \\a maxlen was insufficient to contain the"]
    #[doc = "                                complete output packet."]
    pub fn opus_repacketizer_out_range(
        rp: *mut OpusRepacketizer,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        maxlen: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Return the total number of frames contained in packet data submitted to"]
    #[doc = " the repacketizer state so far via opus_repacketizer_cat() since the last"]
    #[doc = " call to opus_repacketizer_init() or opus_repacketizer_create()."]
    #[doc = " This defines the valid range of packets that can be extracted with"]
    #[doc = " opus_repacketizer_out_range() or opus_repacketizer_out()."]
    #[doc = " @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the"]
    #[doc = "                                       frames."]
    #[doc = " @returns The total number of frames contained in the packet data submitted"]
    #[doc = "          to the repacketizer state."]
    pub fn opus_repacketizer_get_nb_frames(rp: *mut OpusRepacketizer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a new packet from data previously submitted to the repacketizer"]
    #[doc = " state via opus_repacketizer_cat()."]
    #[doc = " This is a convenience routine that returns all the data submitted so far"]
    #[doc = " in a single packet."]
    #[doc = " It is equivalent to calling"]
    #[doc = " @code"]
    #[doc = " opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),"]
    #[doc = "                             data, maxlen)"]
    #[doc = " @endcode"]
    #[doc = " @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to"]
    #[doc = "                                       construct the new packet."]
    #[doc = " @param[out] data <tt>const unsigned char*</tt>: The buffer in which to"]
    #[doc = "                                                 store the output packet."]
    #[doc = " @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in"]
    #[doc = "                                    the output buffer. In order to guarantee"]
    #[doc = "                                    success, this should be at least"]
    #[doc = "                                    <code>1277*opus_repacketizer_get_nb_frames(rp)</code>."]
    #[doc = "                                    However,"]
    #[doc = "                                    <code>1*opus_repacketizer_get_nb_frames(rp)</code>"]
    #[doc = "                                    plus the size of all packet data"]
    #[doc = "                                    submitted to the repacketizer since the"]
    #[doc = "                                    last call to opus_repacketizer_init() or"]
    #[doc = "                                    opus_repacketizer_create() is also"]
    #[doc = "                                    sufficient, and possibly much smaller."]
    #[doc = " @returns The total size of the output packet on success, or an error code"]
    #[doc = "          on failure."]
    #[doc = " @retval #OPUS_BUFFER_TOO_SMALL \\a maxlen was insufficient to contain the"]
    #[doc = "                                complete output packet."]
    pub fn opus_repacketizer_out(
        rp: *mut OpusRepacketizer,
        data: *mut ::std::os::raw::c_uchar,
        maxlen: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Pads a given Opus packet to a larger size (possibly changing the TOC sequence)."]
    #[doc = " @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the"]
    #[doc = "                                                   packet to pad."]
    #[doc = " @param len <tt>opus_int32</tt>: The size of the packet."]
    #[doc = "                                 This must be at least 1."]
    #[doc = " @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding."]
    #[doc = "                                 This must be at least as large as len."]
    #[doc = " @returns an error code"]
    #[doc = " @retval #OPUS_OK \\a on success."]
    #[doc = " @retval #OPUS_BAD_ARG \\a len was less than 1 or new_len was less than len."]
    #[doc = " @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_packet_pad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        new_len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all padding from a given Opus packet and rewrite the TOC sequence to"]
    #[doc = " minimize space usage."]
    #[doc = " @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the"]
    #[doc = "                                                   packet to strip."]
    #[doc = " @param len <tt>opus_int32</tt>: The size of the packet."]
    #[doc = "                                 This must be at least 1."]
    #[doc = " @returns The new size of the output packet on success, or an error code"]
    #[doc = "          on failure."]
    #[doc = " @retval #OPUS_BAD_ARG \\a len was less than 1."]
    #[doc = " @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_packet_unpad(data: *mut ::std::os::raw::c_uchar, len: opus_int32) -> opus_int32;
}
extern "C" {
    #[doc = " Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence)."]
    #[doc = " @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the"]
    #[doc = "                                                   packet to pad."]
    #[doc = " @param len <tt>opus_int32</tt>: The size of the packet."]
    #[doc = "                                 This must be at least 1."]
    #[doc = " @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding."]
    #[doc = "                                 This must be at least 1."]
    #[doc = " @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet."]
    #[doc = "                                 This must be at least as large as len."]
    #[doc = " @returns an error code"]
    #[doc = " @retval #OPUS_OK \\a on success."]
    #[doc = " @retval #OPUS_BAD_ARG \\a len was less than 1."]
    #[doc = " @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_multistream_packet_pad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        new_len: opus_int32,
        nb_streams: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to"]
    #[doc = " minimize space usage."]
    #[doc = " @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the"]
    #[doc = "                                                   packet to strip."]
    #[doc = " @param len <tt>opus_int32</tt>: The size of the packet."]
    #[doc = "                                 This must be at least 1."]
    #[doc = " @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet."]
    #[doc = "                                 This must be at least 1."]
    #[doc = " @returns The new size of the output packet on success, or an error code"]
    #[doc = "          on failure."]
    #[doc = " @retval #OPUS_BAD_ARG \\a len was less than 1 or new_len was less than len."]
    #[doc = " @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_multistream_packet_unpad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        nb_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSEncoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSDecoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an OpusMSEncoder structure."]
    #[doc = " @param streams <tt>int</tt>: The total number of streams to encode from the"]
    #[doc = "                              input."]
    #[doc = "                              This must be no more than 255."]
    #[doc = " @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams"]
    #[doc = "                                      to encode."]
    #[doc = "                                      This must be no larger than the total"]
    #[doc = "                                      number of streams."]
    #[doc = "                                      Additionally, The total number of"]
    #[doc = "                                      encoded channels (<code>streams +"]
    #[doc = "                                      coupled_streams</code>) must be no"]
    #[doc = "                                      more than 255."]
    #[doc = " @returns The size in bytes on success, or a negative error code"]
    #[doc = "          (see @ref opus_errorcodes) on error."]
    pub fn opus_multistream_encoder_get_size(
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
extern "C" {
    pub fn opus_multistream_surround_encoder_get_size(
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Allocates and initializes a multistream encoder state."]
    #[doc = " Call opus_multistream_encoder_destroy() to release"]
    #[doc = " this object when finished."]
    #[doc = " @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz)."]
    #[doc = "                                This must be one of 8000, 12000, 16000,"]
    #[doc = "                                24000, or 48000."]
    #[doc = " @param channels <tt>int</tt>: Number of channels in the input signal."]
    #[doc = "                               This must be at most 255."]
    #[doc = "                               It may be greater than the number of"]
    #[doc = "                               coded channels (<code>streams +"]
    #[doc = "                               coupled_streams</code>)."]
    #[doc = " @param streams <tt>int</tt>: The total number of streams to encode from the"]
    #[doc = "                              input."]
    #[doc = "                              This must be no more than the number of channels."]
    #[doc = " @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams"]
    #[doc = "                                      to encode."]
    #[doc = "                                      This must be no larger than the total"]
    #[doc = "                                      number of streams."]
    #[doc = "                                      Additionally, The total number of"]
    #[doc = "                                      encoded channels (<code>streams +"]
    #[doc = "                                      coupled_streams</code>) must be no"]
    #[doc = "                                      more than the number of input channels."]
    #[doc = " @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from"]
    #[doc = "                    encoded channels to input channels, as described in"]
    #[doc = "                    @ref opus_multistream. As an extra constraint, the"]
    #[doc = "                    multistream encoder does not allow encoding coupled"]
    #[doc = "                    streams for which one channel is unused since this"]
    #[doc = "                    is never a good idea."]
    #[doc = " @param application <tt>int</tt>: The target encoder application."]
    #[doc = "                                  This must be one of the following:"]
    #[doc = " <dl>"]
    #[doc = " <dt>#OPUS_APPLICATION_VOIP</dt>"]
    #[doc = " <dd>Process signal for improved speech intelligibility.</dd>"]
    #[doc = " <dt>#OPUS_APPLICATION_AUDIO</dt>"]
    #[doc = " <dd>Favor faithfulness to the original input.</dd>"]
    #[doc = " <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>"]
    #[doc = " <dd>Configure the minimum possible coding delay by disabling certain modes"]
    #[doc = " of operation.</dd>"]
    #[doc = " </dl>"]
    #[doc = " @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error"]
    #[doc = "                                   code (see @ref opus_errorcodes) on"]
    #[doc = "                                   failure."]
    pub fn opus_multistream_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSEncoder;
}
extern "C" {
    pub fn opus_multistream_surround_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        mapping: *mut ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSEncoder;
}
extern "C" {
    #[doc = " Initialize a previously allocated multistream encoder state."]
    #[doc = " The memory pointed to by \\a st must be at least the size returned by"]
    #[doc = " opus_multistream_encoder_get_size()."]
    #[doc = " This is intended for applications which use their own allocator instead of"]
    #[doc = " malloc."]
    #[doc = " To reset a previously initialized state, use the #OPUS_RESET_STATE CTL."]
    #[doc = " @see opus_multistream_encoder_create"]
    #[doc = " @see opus_multistream_encoder_get_size"]
    #[doc = " @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize."]
    #[doc = " @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz)."]
    #[doc = "                                This must be one of 8000, 12000, 16000,"]
    #[doc = "                                24000, or 48000."]
    #[doc = " @param channels <tt>int</tt>: Number of channels in the input signal."]
    #[doc = "                               This must be at most 255."]
    #[doc = "                               It may be greater than the number of"]
    #[doc = "                               coded channels (<code>streams +"]
    #[doc = "                               coupled_streams</code>)."]
    #[doc = " @param streams <tt>int</tt>: The total number of streams to encode from the"]
    #[doc = "                              input."]
    #[doc = "                              This must be no more than the number of channels."]
    #[doc = " @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams"]
    #[doc = "                                      to encode."]
    #[doc = "                                      This must be no larger than the total"]
    #[doc = "                                      number of streams."]
    #[doc = "                                      Additionally, The total number of"]
    #[doc = "                                      encoded channels (<code>streams +"]
    #[doc = "                                      coupled_streams</code>) must be no"]
    #[doc = "                                      more than the number of input channels."]
    #[doc = " @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from"]
    #[doc = "                    encoded channels to input channels, as described in"]
    #[doc = "                    @ref opus_multistream. As an extra constraint, the"]
    #[doc = "                    multistream encoder does not allow encoding coupled"]
    #[doc = "                    streams for which one channel is unused since this"]
    #[doc = "                    is never a good idea."]
    #[doc = " @param application <tt>int</tt>: The target encoder application."]
    #[doc = "                                  This must be one of the following:"]
    #[doc = " <dl>"]
    #[doc = " <dt>#OPUS_APPLICATION_VOIP</dt>"]
    #[doc = " <dd>Process signal for improved speech intelligibility.</dd>"]
    #[doc = " <dt>#OPUS_APPLICATION_AUDIO</dt>"]
    #[doc = " <dd>Favor faithfulness to the original input.</dd>"]
    #[doc = " <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>"]
    #[doc = " <dd>Configure the minimum possible coding delay by disabling certain modes"]
    #[doc = " of operation.</dd>"]
    #[doc = " </dl>"]
    #[doc = " @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)"]
    #[doc = "          on failure."]
    pub fn opus_multistream_encoder_init(
        st: *mut OpusMSEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn opus_multistream_surround_encoder_init(
        st: *mut OpusMSEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        mapping: *mut ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a multistream Opus frame."]
    #[doc = " @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state."]
    #[doc = " @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved"]
    #[doc = "                                            samples."]
    #[doc = "                                            This must contain"]
    #[doc = "                                            <code>frame_size*channels</code>"]
    #[doc = "                                            samples."]
    #[doc = " @param frame_size <tt>int</tt>: Number of samples per channel in the input"]
    #[doc = "                                 signal."]
    #[doc = "                                 This must be an Opus frame size for the"]
    #[doc = "                                 encoder's sampling rate."]
    #[doc = "                                 For example, at 48 kHz the permitted values"]
    #[doc = "                                 are 120, 240, 480, 960, 1920, and 2880."]
    #[doc = "                                 Passing in a duration of less than 10 ms"]
    #[doc = "                                 (480 samples at 48 kHz) will prevent the"]
    #[doc = "                                 encoder from using the LPC or hybrid modes."]
    #[doc = " @param[out] data <tt>unsigned char*</tt>: Output payload."]
    #[doc = "                                           This must contain storage for at"]
    #[doc = "                                           least \\a max_data_bytes."]
    #[doc = " @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated"]
    #[doc = "                                                 memory for the output"]
    #[doc = "                                                 payload. This may be"]
    #[doc = "                                                 used to impose an upper limit on"]
    #[doc = "                                                 the instant bitrate, but should"]
    #[doc = "                                                 not be used as the only bitrate"]
    #[doc = "                                                 control. Use #OPUS_SET_BITRATE to"]
    #[doc = "                                                 control the bitrate."]
    #[doc = " @returns The length of the encoded packet (in bytes) on success or a"]
    #[doc = "          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode(
        st: *mut OpusMSEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a multistream Opus frame from floating point input."]
    #[doc = " @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state."]
    #[doc = " @param[in] pcm <tt>const float*</tt>: The input signal as interleaved"]
    #[doc = "                                       samples with a normal range of"]
    #[doc = "                                       +/-1.0."]
    #[doc = "                                       Samples with a range beyond +/-1.0"]
    #[doc = "                                       are supported but will be clipped by"]
    #[doc = "                                       decoders using the integer API and"]
    #[doc = "                                       should only be used if it is known"]
    #[doc = "                                       that the far end supports extended"]
    #[doc = "                                       dynamic range."]
    #[doc = "                                       This must contain"]
    #[doc = "                                       <code>frame_size*channels</code>"]
    #[doc = "                                       samples."]
    #[doc = " @param frame_size <tt>int</tt>: Number of samples per channel in the input"]
    #[doc = "                                 signal."]
    #[doc = "                                 This must be an Opus frame size for the"]
    #[doc = "                                 encoder's sampling rate."]
    #[doc = "                                 For example, at 48 kHz the permitted values"]
    #[doc = "                                 are 120, 240, 480, 960, 1920, and 2880."]
    #[doc = "                                 Passing in a duration of less than 10 ms"]
    #[doc = "                                 (480 samples at 48 kHz) will prevent the"]
    #[doc = "                                 encoder from using the LPC or hybrid modes."]
    #[doc = " @param[out] data <tt>unsigned char*</tt>: Output payload."]
    #[doc = "                                           This must contain storage for at"]
    #[doc = "                                           least \\a max_data_bytes."]
    #[doc = " @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated"]
    #[doc = "                                                 memory for the output"]
    #[doc = "                                                 payload. This may be"]
    #[doc = "                                                 used to impose an upper limit on"]
    #[doc = "                                                 the instant bitrate, but should"]
    #[doc = "                                                 not be used as the only bitrate"]
    #[doc = "                                                 control. Use #OPUS_SET_BITRATE to"]
    #[doc = "                                                 control the bitrate."]
    #[doc = " @returns The length of the encoded packet (in bytes) on success or a"]
    #[doc = "          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode_float(
        st: *mut OpusMSEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees an <code>OpusMSEncoder</code> allocated by"]
    #[doc = " opus_multistream_encoder_create()."]
    #[doc = " @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to be freed."]
    pub fn opus_multistream_encoder_destroy(st: *mut OpusMSEncoder);
}
extern "C" {
    #[doc = " Perform a CTL function on a multistream Opus encoder."]
    #[doc = ""]
    #[doc = " Generally the request and subsequent arguments are generated by a"]
    #[doc = " convenience macro."]
    #[doc = " @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state."]
    #[doc = " @param request This and all remaining parameters should be replaced by one"]
    #[doc = "                of the convenience macros in @ref opus_genericctls,"]
    #[doc = "                @ref opus_encoderctls, or @ref opus_multistream_ctls."]
    #[doc = " @see opus_genericctls"]
    #[doc = " @see opus_encoderctls"]
    #[doc = " @see opus_multistream_ctls"]
    pub fn opus_multistream_encoder_ctl(
        st: *mut OpusMSEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusMSDecoder</code> structure."]
    #[doc = " @param streams <tt>int</tt>: The total number of streams coded in the"]
    #[doc = "                              input."]
    #[doc = "                              This must be no more than 255."]
    #[doc = " @param coupled_streams <tt>int</tt>: Number streams to decode as coupled"]
    #[doc = "                                      (2 channel) streams."]
    #[doc = "                                      This must be no larger than the total"]
    #[doc = "                                      number of streams."]
    #[doc = "                                      Additionally, The total number of"]
    #[doc = "                                      coded channels (<code>streams +"]
    #[doc = "                                      coupled_streams</code>) must be no"]
    #[doc = "                                      more than 255."]
    #[doc = " @returns The size in bytes on success, or a negative error code"]
    #[doc = "          (see @ref opus_errorcodes) on error."]
    pub fn opus_multistream_decoder_get_size(
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Allocates and initializes a multistream decoder state."]
    #[doc = " Call opus_multistream_decoder_destroy() to release"]
    #[doc = " this object when finished."]
    #[doc = " @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz)."]
    #[doc = "                                This must be one of 8000, 12000, 16000,"]
    #[doc = "                                24000, or 48000."]
    #[doc = " @param channels <tt>int</tt>: Number of channels to output."]
    #[doc = "                               This must be at most 255."]
    #[doc = "                               It may be different from the number of coded"]
    #[doc = "                               channels (<code>streams +"]
    #[doc = "                               coupled_streams</code>)."]
    #[doc = " @param streams <tt>int</tt>: The total number of streams coded in the"]
    #[doc = "                              input."]
    #[doc = "                              This must be no more than 255."]
    #[doc = " @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled"]
    #[doc = "                                      (2 channel) streams."]
    #[doc = "                                      This must be no larger than the total"]
    #[doc = "                                      number of streams."]
    #[doc = "                                      Additionally, The total number of"]
    #[doc = "                                      coded channels (<code>streams +"]
    #[doc = "                                      coupled_streams</code>) must be no"]
    #[doc = "                                      more than 255."]
    #[doc = " @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from"]
    #[doc = "                    coded channels to output channels, as described in"]
    #[doc = "                    @ref opus_multistream."]
    #[doc = " @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error"]
    #[doc = "                                   code (see @ref opus_errorcodes) on"]
    #[doc = "                                   failure."]
    pub fn opus_multistream_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSDecoder;
}
extern "C" {
    #[doc = " Intialize a previously allocated decoder state object."]
    #[doc = " The memory pointed to by \\a st must be at least the size returned by"]
    #[doc = " opus_multistream_encoder_get_size()."]
    #[doc = " This is intended for applications which use their own allocator instead of"]
    #[doc = " malloc."]
    #[doc = " To reset a previously initialized state, use the #OPUS_RESET_STATE CTL."]
    #[doc = " @see opus_multistream_decoder_create"]
    #[doc = " @see opus_multistream_deocder_get_size"]
    #[doc = " @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize."]
    #[doc = " @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz)."]
    #[doc = "                                This must be one of 8000, 12000, 16000,"]
    #[doc = "                                24000, or 48000."]
    #[doc = " @param channels <tt>int</tt>: Number of channels to output."]
    #[doc = "                               This must be at most 255."]
    #[doc = "                               It may be different from the number of coded"]
    #[doc = "                               channels (<code>streams +"]
    #[doc = "                               coupled_streams</code>)."]
    #[doc = " @param streams <tt>int</tt>: The total number of streams coded in the"]
    #[doc = "                              input."]
    #[doc = "                              This must be no more than 255."]
    #[doc = " @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled"]
    #[doc = "                                      (2 channel) streams."]
    #[doc = "                                      This must be no larger than the total"]
    #[doc = "                                      number of streams."]
    #[doc = "                                      Additionally, The total number of"]
    #[doc = "                                      coded channels (<code>streams +"]
    #[doc = "                                      coupled_streams</code>) must be no"]
    #[doc = "                                      more than 255."]
    #[doc = " @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from"]
    #[doc = "                    coded channels to output channels, as described in"]
    #[doc = "                    @ref opus_multistream."]
    #[doc = " @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)"]
    #[doc = "          on failure."]
    pub fn opus_multistream_decoder_init(
        st: *mut OpusMSDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a multistream Opus packet."]
    #[doc = " @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state."]
    #[doc = " @param[in] data <tt>const unsigned char*</tt>: Input payload."]
    #[doc = "                                                Use a <code>NULL</code>"]
    #[doc = "                                                pointer to indicate packet"]
    #[doc = "                                                loss."]
    #[doc = " @param len <tt>opus_int32</tt>: Number of bytes in payload."]
    #[doc = " @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved"]
    #[doc = "                                       samples."]
    #[doc = "                                       This must contain room for"]
    #[doc = "                                       <code>frame_size*channels</code>"]
    #[doc = "                                       samples."]
    #[doc = " @param frame_size <tt>int</tt>: The number of samples per channel of"]
    #[doc = "                                 available space in \\a pcm."]
    #[doc = "                                 If this is less than the maximum packet duration"]
    #[doc = "                                 (120 ms; 5760 for 48kHz), this function will not be capable"]
    #[doc = "                                 of decoding some packets. In the case of PLC (data==NULL)"]
    #[doc = "                                 or FEC (decode_fec=1), then frame_size needs to be exactly"]
    #[doc = "                                 the duration of audio that is missing, otherwise the"]
    #[doc = "                                 decoder will not be in the optimal state to decode the"]
    #[doc = "                                 next incoming packet. For the PLC and FEC cases, frame_size"]
    #[doc = "                                 <b>must</b> be a multiple of 2.5 ms."]
    #[doc = " @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band"]
    #[doc = "                                 forward error correction data be decoded."]
    #[doc = "                                 If no such data is available, the frame is"]
    #[doc = "                                 decoded as if it were lost."]
    #[doc = " @returns Number of samples decoded on success or a negative error code"]
    #[doc = "          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a multistream Opus packet with floating point output."]
    #[doc = " @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state."]
    #[doc = " @param[in] data <tt>const unsigned char*</tt>: Input payload."]
    #[doc = "                                                Use a <code>NULL</code>"]
    #[doc = "                                                pointer to indicate packet"]
    #[doc = "                                                loss."]
    #[doc = " @param len <tt>opus_int32</tt>: Number of bytes in payload."]
    #[doc = " @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved"]
    #[doc = "                                       samples."]
    #[doc = "                                       This must contain room for"]
    #[doc = "                                       <code>frame_size*channels</code>"]
    #[doc = "                                       samples."]
    #[doc = " @param frame_size <tt>int</tt>: The number of samples per channel of"]
    #[doc = "                                 available space in \\a pcm."]
    #[doc = "                                 If this is less than the maximum packet duration"]
    #[doc = "                                 (120 ms; 5760 for 48kHz), this function will not be capable"]
    #[doc = "                                 of decoding some packets. In the case of PLC (data==NULL)"]
    #[doc = "                                 or FEC (decode_fec=1), then frame_size needs to be exactly"]
    #[doc = "                                 the duration of audio that is missing, otherwise the"]
    #[doc = "                                 decoder will not be in the optimal state to decode the"]
    #[doc = "                                 next incoming packet. For the PLC and FEC cases, frame_size"]
    #[doc = "                                 <b>must</b> be a multiple of 2.5 ms."]
    #[doc = " @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band"]
    #[doc = "                                 forward error correction data be decoded."]
    #[doc = "                                 If no such data is available, the frame is"]
    #[doc = "                                 decoded as if it were lost."]
    #[doc = " @returns Number of samples decoded on success or a negative error code"]
    #[doc = "          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode_float(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a CTL function on a multistream Opus decoder."]
    #[doc = ""]
    #[doc = " Generally the request and subsequent arguments are generated by a"]
    #[doc = " convenience macro."]
    #[doc = " @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state."]
    #[doc = " @param request This and all remaining parameters should be replaced by one"]
    #[doc = "                of the convenience macros in @ref opus_genericctls,"]
    #[doc = "                @ref opus_decoderctls, or @ref opus_multistream_ctls."]
    #[doc = " @see opus_genericctls"]
    #[doc = " @see opus_decoderctls"]
    #[doc = " @see opus_multistream_ctls"]
    pub fn opus_multistream_decoder_ctl(
        st: *mut OpusMSDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees an <code>OpusMSDecoder</code> allocated by"]
    #[doc = " opus_multistream_decoder_create()."]
    #[doc = " @param st <tt>OpusMSDecoder</tt>: Multistream decoder state to be freed."]
    pub fn opus_multistream_decoder_destroy(st: *mut OpusMSDecoder);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OggOpusFile {
    _unused: [u8; 0],
}
#[doc = "Ogg Opus bitstream information."]
#[doc = "This contains the basic playback parameters for a stream, and corresponds to"]
#[doc = "the initial ID header packet of an Ogg Opus stream."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpusHead {
    #[doc = "The Ogg Opus format version, in the range 0...255."]
    #[doc = "The top 4 bits represent a \"major\" version, and the bottom four bits"]
    #[doc = "represent backwards-compatible \"minor\" revisions."]
    #[doc = "The current specification describes version 1."]
    #[doc = "This library will recognize versions up through 15 as backwards compatible"]
    #[doc = "with the current specification."]
    #[doc = "An earlier draft of the specification described a version 0, but the only"]
    #[doc = "difference between version 1 and version 0 is that version 0 did"]
    #[doc = "not specify the semantics for handling the version field."]
    pub version: ::std::os::raw::c_int,
    #[doc = "The number of channels, in the range 1...255."]
    pub channel_count: ::std::os::raw::c_int,
    #[doc = "The number of samples that should be discarded from the beginning of the"]
    #[doc = "stream."]
    pub pre_skip: ::std::os::raw::c_uint,
    #[doc = "The sampling rate of the original input."]
    #[doc = "All Opus audio is coded at 48 kHz, and should also be decoded at 48 kHz"]
    #[doc = "for playback (unless the target hardware does not support this sampling"]
    #[doc = "rate)."]
    #[doc = "However, this field may be used to resample the audio back to the original"]
    #[doc = "sampling rate, for example, when saving the output to a file."]
    pub input_sample_rate: opus_uint32,
    #[doc = "The gain to apply to the decoded output, in dB, as a Q8 value in the range"]
    #[doc = "-32768...32767."]
    #[doc = "The <tt>libopusfile</tt> API will automatically apply this gain to the"]
    #[doc = "decoded output before returning it, scaling it by"]
    #[doc = "<code>pow(10,output_gain/(20.0*256))</code>."]
    #[doc = "You can adjust this behavior with op_set_gain_offset()."]
    pub output_gain: ::std::os::raw::c_int,
    #[doc = "The channel mapping family, in the range 0...255."]
    #[doc = "Channel mapping family 0 covers mono or stereo in a single stream."]
    #[doc = "Channel mapping family 1 covers 1 to 8 channels in one or more streams,"]
    #[doc = "using the Vorbis speaker assignments."]
    #[doc = "Channel mapping family 255 covers 1 to 255 channels in one or more"]
    #[doc = "streams, but without any defined speaker assignment."]
    pub mapping_family: ::std::os::raw::c_int,
    #[doc = "The number of Opus streams in each Ogg packet, in the range 1...255."]
    pub stream_count: ::std::os::raw::c_int,
    #[doc = "The number of coupled Opus streams in each Ogg packet, in the range"]
    #[doc = "0...127."]
    #[doc = "This must satisfy <code>0 <= coupled_count <= stream_count</code> and"]
    #[doc = "<code>coupled_count + stream_count <= 255</code>."]
    #[doc = "The coupled streams appear first, before all uncoupled streams, in an Ogg"]
    #[doc = "Opus packet."]
    pub coupled_count: ::std::os::raw::c_int,
    #[doc = "The mapping from coded stream channels to output channels."]
    #[doc = "Let <code>index=mapping[k]</code> be the value for channel <code>k</code>."]
    #[doc = "If <code>index<2*coupled_count</code>, then it refers to the left channel"]
    #[doc = "from stream <code>(index/2)</code> if even, and the right channel from"]
    #[doc = "stream <code>(index/2)</code> if odd."]
    #[doc = "Otherwise, it refers to the output of the uncoupled stream"]
    #[doc = "<code>(index-coupled_count)</code>."]
    pub mapping: [::std::os::raw::c_uchar; 255usize],
}
#[test]
fn bindgen_test_layout_OpusHead() {
    assert_eq!(
        ::std::mem::size_of::<OpusHead>(),
        288usize,
        concat!("Size of: ", stringify!(OpusHead))
    );
    assert_eq!(
        ::std::mem::align_of::<OpusHead>(),
        4usize,
        concat!("Alignment of ", stringify!(OpusHead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).channel_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).pre_skip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(pre_skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).input_sample_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(input_sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).output_gain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(output_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).mapping_family as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(mapping_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).stream_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(stream_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).coupled_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(coupled_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusHead>())).mapping as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusHead),
            "::",
            stringify!(mapping)
        )
    );
}
#[doc = "The metadata from an Ogg Opus stream."]
#[doc = ""]
#[doc = "This structure holds the in-stream metadata corresponding to the 'comment'"]
#[doc = "header packet of an Ogg Opus stream."]
#[doc = "The comment header is meant to be used much like someone jotting a quick"]
#[doc = "note on the label of a CD."]
#[doc = "It should be a short, to the point text note that can be more than a couple"]
#[doc = "words, but not more than a short paragraph."]
#[doc = ""]
#[doc = "The metadata is stored as a series of (tag, value) pairs, in length-encoded"]
#[doc = "string vectors, using the same format as Vorbis (without the final \"framing"]
#[doc = "bit\"), Theora, and Speex, except for the packet header."]
#[doc = "The first occurrence of the '=' character delimits the tag and value."]
#[doc = "A particular tag may occur more than once, and order is significant."]
#[doc = "The character set encoding for the strings is always UTF-8, but the tag"]
#[doc = "names are limited to ASCII, and treated as case-insensitive."]
#[doc = "See <a href=\"http://www.xiph.org/vorbis/doc/v-comment.html\">the Vorbis"]
#[doc = "comment header specification</a> for details."]
#[doc = ""]
#[doc = "In filling in this structure, <tt>libopusfile</tt> will null-terminate the"]
#[doc = "#user_comments strings for safety."]
#[doc = "However, the bitstream format itself treats them as 8-bit clean vectors,"]
#[doc = "possibly containing NUL characters, so the #comment_lengths array should be"]
#[doc = "treated as their authoritative length."]
#[doc = ""]
#[doc = "This structure is binary and source-compatible with a"]
#[doc = "<code>vorbis_comment</code>, and pointers to it may be freely cast to"]
#[doc = "<code>vorbis_comment</code> pointers, and vice versa."]
#[doc = "It is provided as a separate type to avoid introducing a compile-time"]
#[doc = "dependency on the libvorbis headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusTags {
    #[doc = "The array of comment string vectors."]
    pub user_comments: *mut *mut ::std::os::raw::c_char,
    #[doc = "An array of the corresponding length of each vector, in bytes."]
    pub comment_lengths: *mut ::std::os::raw::c_int,
    #[doc = "The total number of comment streams."]
    pub comments: ::std::os::raw::c_int,
    #[doc = "The null-terminated vendor string."]
    #[doc = "This identifies the software used to encode the stream."]
    pub vendor: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OpusTags() {
    assert_eq!(
        ::std::mem::size_of::<OpusTags>(),
        32usize,
        concat!("Size of: ", stringify!(OpusTags))
    );
    assert_eq!(
        ::std::mem::align_of::<OpusTags>(),
        8usize,
        concat!("Alignment of ", stringify!(OpusTags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusTags>())).user_comments as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusTags),
            "::",
            stringify!(user_comments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusTags>())).comment_lengths as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusTags),
            "::",
            stringify!(comment_lengths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusTags>())).comments as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusTags),
            "::",
            stringify!(comments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusTags>())).vendor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusTags),
            "::",
            stringify!(vendor)
        )
    );
}
#[doc = "The contents of a METADATA_BLOCK_PICTURE tag."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusPictureTag {
    #[doc = "The picture type according to the ID3v2 APIC frame:"]
    #[doc = "<ol start=\"0\">"]
    #[doc = "<li>Other</li>"]
    #[doc = "<li>32x32 pixels 'file icon' (PNG only)</li>"]
    #[doc = "<li>Other file icon</li>"]
    #[doc = "<li>Cover (front)</li>"]
    #[doc = "<li>Cover (back)</li>"]
    #[doc = "<li>Leaflet page</li>"]
    #[doc = "<li>Media (e.g. label side of CD)</li>"]
    #[doc = "<li>Lead artist/lead performer/soloist</li>"]
    #[doc = "<li>Artist/performer</li>"]
    #[doc = "<li>Conductor</li>"]
    #[doc = "<li>Band/Orchestra</li>"]
    #[doc = "<li>Composer</li>"]
    #[doc = "<li>Lyricist/text writer</li>"]
    #[doc = "<li>Recording Location</li>"]
    #[doc = "<li>During recording</li>"]
    #[doc = "<li>During performance</li>"]
    #[doc = "<li>Movie/video screen capture</li>"]
    #[doc = "<li>A bright colored fish</li>"]
    #[doc = "<li>Illustration</li>"]
    #[doc = "<li>Band/artist logotype</li>"]
    #[doc = "<li>Publisher/Studio logotype</li>"]
    #[doc = "</ol>"]
    #[doc = "Others are reserved and should not be used."]
    #[doc = "There may only be one each of picture type 1 and 2 in a file."]
    pub type_: opus_int32,
    #[doc = "The MIME type of the picture, in printable ASCII characters 0x20-0x7E."]
    #[doc = "The MIME type may also be <code>\"-->\"</code> to signify that the data part"]
    #[doc = "is a URL pointing to the picture instead of the picture data itself."]
    #[doc = "In this case, a terminating NUL is appended to the URL string in #data,"]
    #[doc = "but #data_length is set to the length of the string excluding that"]
    #[doc = "terminating NUL."]
    pub mime_type: *mut ::std::os::raw::c_char,
    #[doc = "The description of the picture, in UTF-8."]
    pub description: *mut ::std::os::raw::c_char,
    #[doc = "The width of the picture in pixels."]
    pub width: opus_uint32,
    #[doc = "The height of the picture in pixels."]
    pub height: opus_uint32,
    #[doc = "The color depth of the picture in bits-per-pixel (<em>not</em>"]
    #[doc = "bits-per-channel)."]
    pub depth: opus_uint32,
    #[doc = "For indexed-color pictures (e.g., GIF), the number of colors used, or 0"]
    #[doc = "for non-indexed pictures."]
    pub colors: opus_uint32,
    #[doc = "The length of the picture data in bytes."]
    pub data_length: opus_uint32,
    #[doc = "The binary picture data."]
    pub data: *mut ::std::os::raw::c_uchar,
    #[doc = "The format of the picture data, if known."]
    #[doc = "One of"]
    #[doc = "<ul>"]
    #[doc = "<li>#OP_PIC_FORMAT_UNKNOWN,</li>"]
    #[doc = "<li>#OP_PIC_FORMAT_URL,</li>"]
    #[doc = "<li>#OP_PIC_FORMAT_JPEG,</li>"]
    #[doc = "<li>#OP_PIC_FORMAT_PNG, or</li>"]
    #[doc = "<li>#OP_PIC_FORMAT_GIF.</li>"]
    #[doc = "</ul>"]
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OpusPictureTag() {
    assert_eq!(
        ::std::mem::size_of::<OpusPictureTag>(),
        64usize,
        concat!("Size of: ", stringify!(OpusPictureTag))
    );
    assert_eq!(
        ::std::mem::align_of::<OpusPictureTag>(),
        8usize,
        concat!("Alignment of ", stringify!(OpusPictureTag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).mime_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).description as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).depth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).colors as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).data_length as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusPictureTag>())).format as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusPictureTag),
            "::",
            stringify!(format)
        )
    );
}
extern "C" {
    #[doc = "Parses the contents of the ID header packet of an Ogg Opus stream."]
    #[doc = "\\param[out] _head Returns the contents of the parsed packet."]
    #[doc = "The contents of this structure are untouched on error."]
    #[doc = "This may be <code>NULL</code> to merely test the header"]
    #[doc = "for validity."]
    #[doc = "\\param[in]  _data The contents of the ID header packet."]
    #[doc = "\\param      _len  The number of bytes of data in the ID header packet."]
    #[doc = "\\return 0 on success or a negative value on error."]
    #[doc = "\\retval #OP_ENOTFORMAT If the data does not start with the \"OpusHead\""]
    #[doc = "string."]
    #[doc = "\\retval #OP_EVERSION   If the version field signaled a version this library"]
    #[doc = "does not know how to parse."]
    #[doc = "\\retval #OP_EIMPL      If the channel mapping family was 255, which general"]
    #[doc = "purpose players should not attempt to play."]
    #[doc = "\\retval #OP_EBADHEADER If the contents of the packet otherwise violate the"]
    #[doc = "Ogg Opus specification:"]
    #[doc = "<ul>"]
    #[doc = "<li>Insufficient data,</li>"]
    #[doc = "<li>Too much data for the known minor versions,</li>"]
    #[doc = "<li>An unrecognized channel mapping family,</li>"]
    #[doc = "<li>Zero channels or too many channels,</li>"]
    #[doc = "<li>Zero coded streams,</li>"]
    #[doc = "<li>Too many coupled streams, or</li>"]
    #[doc = "<li>An invalid channel mapping index.</li>"]
    #[doc = "</ul>"]
    pub fn opus_head_parse(
        _head: *mut OpusHead,
        _data: *const ::std::os::raw::c_uchar,
        _len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Converts a granule position to a sample offset for a given Ogg Opus stream."]
    #[doc = "The sample offset is simply <code>_gp-_head->pre_skip</code>."]
    #[doc = "Granule position values smaller than OpusHead#pre_skip correspond to audio"]
    #[doc = "that should never be played, and thus have no associated sample offset."]
    #[doc = "This function returns -1 for such values."]
    #[doc = "This function also correctly handles extremely large granule positions,"]
    #[doc = "which may have wrapped around to a negative number when stored in a signed"]
    #[doc = "ogg_int64_t value."]
    #[doc = "\\param _head The #OpusHead information from the ID header of the stream."]
    #[doc = "\\param _gp   The granule position to convert."]
    #[doc = "\\return The sample offset associated with the given granule position"]
    #[doc = "(counting at a 48 kHz sampling rate), or the special value -1 on"]
    #[doc = "error (i.e., the granule position was smaller than the pre-skip"]
    #[doc = "amount)."]
    pub fn opus_granule_sample(_head: *const OpusHead, _gp: ogg_int64_t) -> ogg_int64_t;
}
extern "C" {
    #[doc = "Parses the contents of the 'comment' header packet of an Ogg Opus stream."]
    #[doc = "\\param[out] _tags An uninitialized #OpusTags structure."]
    #[doc = "This returns the contents of the parsed packet."]
    #[doc = "The contents of this structure are untouched on error."]
    #[doc = "This may be <code>NULL</code> to merely test the header"]
    #[doc = "for validity."]
    #[doc = "\\param[in]  _data The contents of the 'comment' header packet."]
    #[doc = "\\param      _len  The number of bytes of data in the 'info' header packet."]
    #[doc = "\\retval 0              Success."]
    #[doc = "\\retval #OP_ENOTFORMAT If the data does not start with the \"OpusTags\""]
    #[doc = "string."]
    #[doc = "\\retval #OP_EBADHEADER If the contents of the packet otherwise violate the"]
    #[doc = "Ogg Opus specification."]
    #[doc = "\\retval #OP_EFAULT     If there wasn't enough memory to store the tags."]
    pub fn opus_tags_parse(
        _tags: *mut OpusTags,
        _data: *const ::std::os::raw::c_uchar,
        _len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Performs a deep copy of an #OpusTags structure."]
    #[doc = "\\param _dst The #OpusTags structure to copy into."]
    #[doc = "If this function fails, the contents of this structure remain"]
    #[doc = "untouched."]
    #[doc = "\\param _src The #OpusTags structure to copy from."]
    #[doc = "\\retval 0          Success."]
    #[doc = "\\retval #OP_EFAULT If there wasn't enough memory to copy the tags."]
    pub fn opus_tags_copy(_dst: *mut OpusTags, _src: *const OpusTags) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Initializes an #OpusTags structure."]
    #[doc = "This should be called on a freshly allocated #OpusTags structure before"]
    #[doc = "attempting to use it."]
    #[doc = "\\param _tags The #OpusTags structure to initialize."]
    pub fn opus_tags_init(_tags: *mut OpusTags);
}
extern "C" {
    #[doc = "Add a (tag, value) pair to an initialized #OpusTags structure."]
    #[doc = "\\note Neither opus_tags_add() nor opus_tags_add_comment() support values"]
    #[doc = "containing embedded NULs, although the bitstream format does support them."]
    #[doc = "To add such tags, you will need to manipulate the #OpusTags structure"]
    #[doc = "directly."]
    #[doc = "\\param _tags  The #OpusTags structure to add the (tag, value) pair to."]
    #[doc = "\\param _tag   A NUL-terminated, case-insensitive, ASCII string containing"]
    #[doc = "the tag to add (without an '=' character)."]
    #[doc = "\\param _value A NUL-terminated UTF-8 containing the corresponding value."]
    #[doc = "\\return 0 on success, or a negative value on failure."]
    #[doc = "\\retval #OP_EFAULT An internal memory allocation failed."]
    pub fn opus_tags_add(
        _tags: *mut OpusTags,
        _tag: *const ::std::os::raw::c_char,
        _value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add a comment to an initialized #OpusTags structure."]
    #[doc = "\\note Neither opus_tags_add_comment() nor opus_tags_add() support comments"]
    #[doc = "containing embedded NULs, although the bitstream format does support them."]
    #[doc = "To add such tags, you will need to manipulate the #OpusTags structure"]
    #[doc = "directly."]
    #[doc = "\\param _tags    The #OpusTags structure to add the comment to."]
    #[doc = "\\param _comment A NUL-terminated UTF-8 string containing the comment in"]
    #[doc = "\"TAG=value\" form."]
    #[doc = "\\return 0 on success, or a negative value on failure."]
    #[doc = "\\retval #OP_EFAULT An internal memory allocation failed."]
    pub fn opus_tags_add_comment(
        _tags: *mut OpusTags,
        _comment: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Replace the binary suffix data at the end of the packet (if any)."]
    #[doc = "\\param _tags An initialized #OpusTags structure."]
    #[doc = "\\param _data A buffer of binary data to append after the encoded user"]
    #[doc = "comments."]
    #[doc = "The least significant bit of the first byte of this data must"]
    #[doc = "be set (to ensure the data is preserved by other editors)."]
    #[doc = "\\param _len  The number of bytes of binary data to append."]
    #[doc = "This may be zero to remove any existing binary suffix data."]
    #[doc = "\\return 0 on success, or a negative value on error."]
    #[doc = "\\retval #OP_EINVAL \\a _len was negative, or \\a _len was positive but"]
    #[doc = "\\a _data was <code>NULL</code> or the least significant"]
    #[doc = "bit of the first byte was not set."]
    #[doc = "\\retval #OP_EFAULT An internal memory allocation failed."]
    pub fn opus_tags_set_binary_suffix(
        _tags: *mut OpusTags,
        _data: *const ::std::os::raw::c_uchar,
        _len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Look up a comment value by its tag."]
    #[doc = "\\param _tags  An initialized #OpusTags structure."]
    #[doc = "\\param _tag   The tag to look up."]
    #[doc = "\\param _count The instance of the tag."]
    #[doc = "The same tag can appear multiple times, each with a distinct"]
    #[doc = "value, so an index is required to retrieve them all."]
    #[doc = "The order in which these values appear is significant and"]
    #[doc = "should be preserved."]
    #[doc = "Use opus_tags_query_count() to get the legal range for the"]
    #[doc = "\\a _count parameter."]
    #[doc = "\\return A pointer to the queried tag's value."]
    #[doc = "This points directly to data in the #OpusTags structure."]
    #[doc = "It should not be modified or freed by the application, and"]
    #[doc = "modifications to the structure may invalidate the pointer."]
    #[doc = "\\retval NULL If no matching tag is found."]
    pub fn opus_tags_query(
        _tags: *const OpusTags,
        _tag: *const ::std::os::raw::c_char,
        _count: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Look up the number of instances of a tag."]
    #[doc = "Call this first when querying for a specific tag and then iterate over the"]
    #[doc = "number of instances with separate calls to opus_tags_query() to retrieve"]
    #[doc = "all the values for that tag in order."]
    #[doc = "\\param _tags An initialized #OpusTags structure."]
    #[doc = "\\param _tag  The tag to look up."]
    #[doc = "\\return The number of instances of this particular tag."]
    pub fn opus_tags_query_count(
        _tags: *const OpusTags,
        _tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Retrieve the binary suffix data at the end of the packet (if any)."]
    #[doc = "\\param      _tags An initialized #OpusTags structure."]
    #[doc = "\\param[out] _len  Returns the number of bytes of binary suffix data returned."]
    #[doc = "\\return A pointer to the binary suffix data, or <code>NULL</code> if none"]
    #[doc = "was present."]
    pub fn opus_tags_get_binary_suffix(
        _tags: *const OpusTags,
        _len: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = "Get the album gain from an R128_ALBUM_GAIN tag, if one was specified."]
    #[doc = "This searches for the first R128_ALBUM_GAIN tag with a valid signed,"]
    #[doc = "16-bit decimal integer value and returns the value."]
    #[doc = "This routine is exposed merely for convenience for applications which wish"]
    #[doc = "to do something special with the album gain (i.e., display it)."]
    #[doc = "If you simply wish to apply the album gain instead of the header gain, you"]
    #[doc = "can use op_set_gain_offset() with an #OP_ALBUM_GAIN type and no offset."]
    #[doc = "\\param      _tags    An initialized #OpusTags structure."]
    #[doc = "\\param[out] _gain_q8 The album gain, in 1/256ths of a dB."]
    #[doc = "This will lie in the range [-32768,32767], and should"]
    #[doc = "be applied in <em>addition</em> to the header gain."]
    #[doc = "On error, no value is returned, and the previous"]
    #[doc = "contents remain unchanged."]
    #[doc = "\\return 0 on success, or a negative value on error."]
    #[doc = "\\retval #OP_FALSE There was no album gain available in the given tags."]
    pub fn opus_tags_get_album_gain(
        _tags: *const OpusTags,
        _gain_q8: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the track gain from an R128_TRACK_GAIN tag, if one was specified."]
    #[doc = "This searches for the first R128_TRACK_GAIN tag with a valid signed,"]
    #[doc = "16-bit decimal integer value and returns the value."]
    #[doc = "This routine is exposed merely for convenience for applications which wish"]
    #[doc = "to do something special with the track gain (i.e., display it)."]
    #[doc = "If you simply wish to apply the track gain instead of the header gain, you"]
    #[doc = "can use op_set_gain_offset() with an #OP_TRACK_GAIN type and no offset."]
    #[doc = "\\param      _tags    An initialized #OpusTags structure."]
    #[doc = "\\param[out] _gain_q8 The track gain, in 1/256ths of a dB."]
    #[doc = "This will lie in the range [-32768,32767], and should"]
    #[doc = "be applied in <em>addition</em> to the header gain."]
    #[doc = "On error, no value is returned, and the previous"]
    #[doc = "contents remain unchanged."]
    #[doc = "\\return 0 on success, or a negative value on error."]
    #[doc = "\\retval #OP_FALSE There was no track gain available in the given tags."]
    pub fn opus_tags_get_track_gain(
        _tags: *const OpusTags,
        _gain_q8: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Clears the #OpusTags structure."]
    #[doc = "This should be called on an #OpusTags structure after it is no longer"]
    #[doc = "needed."]
    #[doc = "It will free all memory used by the structure members."]
    #[doc = "\\param _tags The #OpusTags structure to clear."]
    pub fn opus_tags_clear(_tags: *mut OpusTags);
}
extern "C" {
    #[doc = "Check if \\a _comment is an instance of a \\a _tag_name tag."]
    #[doc = "\\see opus_tagncompare"]
    #[doc = "\\param _tag_name A NUL-terminated, case-insensitive, ASCII string containing"]
    #[doc = "the name of the tag to check for (without the terminating"]
    #[doc = "'=' character)."]
    #[doc = "\\param _comment  The comment string to check."]
    #[doc = "\\return An integer less than, equal to, or greater than zero if \\a _comment"]
    #[doc = "is found respectively, to be less than, to match, or be greater"]
    #[doc = "than a \"tag=value\" string whose tag matches \\a _tag_name."]
    pub fn opus_tagcompare(
        _tag_name: *const ::std::os::raw::c_char,
        _comment: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Check if \\a _comment is an instance of a \\a _tag_name tag."]
    #[doc = "This version is slightly more efficient than opus_tagcompare() if the length"]
    #[doc = "of the tag name is already known (e.g., because it is a constant)."]
    #[doc = "\\see opus_tagcompare"]
    #[doc = "\\param _tag_name A case-insensitive ASCII string containing the name of the"]
    #[doc = "tag to check for (without the terminating '=' character)."]
    #[doc = "\\param _tag_len  The number of characters in the tag name."]
    #[doc = "This must be non-negative."]
    #[doc = "\\param _comment  The comment string to check."]
    #[doc = "\\return An integer less than, equal to, or greater than zero if \\a _comment"]
    #[doc = "is found respectively, to be less than, to match, or be greater"]
    #[doc = "than a \"tag=value\" string whose tag matches the first \\a _tag_len"]
    #[doc = "characters of \\a _tag_name."]
    pub fn opus_tagncompare(
        _tag_name: *const ::std::os::raw::c_char,
        _tag_len: ::std::os::raw::c_int,
        _comment: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Parse a single METADATA_BLOCK_PICTURE tag."]
    #[doc = "This decodes the BASE64-encoded content of the tag and returns a structure"]
    #[doc = "with the MIME type, description, image parameters (if known), and the"]
    #[doc = "compressed image data."]
    #[doc = "If the MIME type indicates the presence of an image format we recognize"]
    #[doc = "(JPEG, PNG, or GIF) and the actual image data contains the magic signature"]
    #[doc = "associated with that format, then the OpusPictureTag::format field will be"]
    #[doc = "set to the corresponding format."]
    #[doc = "This is provided as a convenience to avoid requiring applications to parse"]
    #[doc = "the MIME type and/or do their own format detection for the commonly used"]
    #[doc = "formats."]
    #[doc = "In this case, we also attempt to extract the image parameters directly from"]
    #[doc = "the image data (overriding any that were present in the tag, which the"]
    #[doc = "specification says applications are not meant to rely on)."]
    #[doc = "The application must still provide its own support for actually decoding the"]
    #[doc = "image data and, if applicable, retrieving that data from URLs."]
    #[doc = "\\param[out] _pic Returns the parsed picture data."]
    #[doc = "No sanitation is done on the type, MIME type, or"]
    #[doc = "description fields, so these might return invalid values."]
    #[doc = "The contents of this structure are left unmodified on"]
    #[doc = "failure."]
    #[doc = "\\param      _tag The METADATA_BLOCK_PICTURE tag contents."]
    #[doc = "The leading \"METADATA_BLOCK_PICTURE=\" portion is optional,"]
    #[doc = "to allow the function to be used on either directly on the"]
    #[doc = "values in OpusTags::user_comments or on the return value"]
    #[doc = "of opus_tags_query()."]
    #[doc = "\\return 0 on success or a negative value on error."]
    #[doc = "\\retval #OP_ENOTFORMAT The METADATA_BLOCK_PICTURE contents were not valid."]
    #[doc = "\\retval #OP_EFAULT     There was not enough memory to store the picture tag"]
    #[doc = "contents."]
    pub fn opus_picture_tag_parse(
        _pic: *mut OpusPictureTag,
        _tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Initializes an #OpusPictureTag structure."]
    #[doc = "This should be called on a freshly allocated #OpusPictureTag structure"]
    #[doc = "before attempting to use it."]
    #[doc = "\\param _pic The #OpusPictureTag structure to initialize."]
    pub fn opus_picture_tag_init(_pic: *mut OpusPictureTag);
}
extern "C" {
    #[doc = "Clears the #OpusPictureTag structure."]
    #[doc = "This should be called on an #OpusPictureTag structure after it is no longer"]
    #[doc = "needed."]
    #[doc = "It will free all memory used by the structure members."]
    #[doc = "\\param _pic The #OpusPictureTag structure to clear."]
    pub fn opus_picture_tag_clear(_pic: *mut OpusPictureTag);
}
#[doc = "HTTP/Shoutcast/Icecast server information associated with a URL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusServerInfo {
    #[doc = "The name of the server (icy-name/ice-name)."]
    #[doc = "This is <code>NULL</code> if there was no <code>icy-name</code> or"]
    #[doc = "<code>ice-name</code> header."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "A short description of the server (icy-description/ice-description)."]
    #[doc = "This is <code>NULL</code> if there was no <code>icy-description</code> or"]
    #[doc = "<code>ice-description</code> header."]
    pub description: *mut ::std::os::raw::c_char,
    #[doc = "The genre the server falls under (icy-genre/ice-genre)."]
    #[doc = "This is <code>NULL</code> if there was no <code>icy-genre</code> or"]
    #[doc = "<code>ice-genre</code> header."]
    pub genre: *mut ::std::os::raw::c_char,
    #[doc = "The homepage for the server (icy-url/ice-url)."]
    #[doc = "This is <code>NULL</code> if there was no <code>icy-url</code> or"]
    #[doc = "<code>ice-url</code> header."]
    pub url: *mut ::std::os::raw::c_char,
    #[doc = "The software used by the origin server (Server)."]
    #[doc = "This is <code>NULL</code> if there was no <code>Server</code> header."]
    pub server: *mut ::std::os::raw::c_char,
    #[doc = "The media type of the entity sent to the recepient (Content-Type)."]
    #[doc = "This is <code>NULL</code> if there was no <code>Content-Type</code>"]
    #[doc = "header."]
    pub content_type: *mut ::std::os::raw::c_char,
    #[doc = "The nominal stream bitrate in kbps (icy-br/ice-bitrate)."]
    #[doc = "This is <code>-1</code> if there was no <code>icy-br</code> or"]
    #[doc = "<code>ice-bitrate</code> header."]
    pub bitrate_kbps: opus_int32,
    #[doc = "Flag indicating whether the server is public (<code>1</code>) or not"]
    #[doc = "(<code>0</code>) (icy-pub/ice-public)."]
    #[doc = "This is <code>-1</code> if there was no <code>icy-pub</code> or"]
    #[doc = "<code>ice-public</code> header."]
    pub is_public: ::std::os::raw::c_int,
    #[doc = "Flag indicating whether the server is using HTTPS instead of HTTP."]
    #[doc = "This is <code>0</code> unless HTTPS is being used."]
    #[doc = "This may not match the protocol used in the original URL if there were"]
    #[doc = "redirections."]
    pub is_ssl: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OpusServerInfo() {
    assert_eq!(
        ::std::mem::size_of::<OpusServerInfo>(),
        64usize,
        concat!("Size of: ", stringify!(OpusServerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OpusServerInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OpusServerInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).genre as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(genre)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).url as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).server as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).content_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).bitrate_kbps as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(bitrate_kbps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).is_public as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(is_public)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusServerInfo>())).is_ssl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusServerInfo),
            "::",
            stringify!(is_ssl)
        )
    );
}
extern "C" {
    #[doc = "Initializes an #OpusServerInfo structure."]
    #[doc = "All fields are set as if the corresponding header was not available."]
    #[doc = "\\param _info The #OpusServerInfo structure to initialize."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    pub fn opus_server_info_init(_info: *mut OpusServerInfo);
}
extern "C" {
    #[doc = "Clears the #OpusServerInfo structure."]
    #[doc = "This should be called on an #OpusServerInfo structure after it is no longer"]
    #[doc = "needed."]
    #[doc = "It will free all memory used by the structure members."]
    #[doc = "\\param _info The #OpusServerInfo structure to clear."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    pub fn opus_server_info_clear(_info: *mut OpusServerInfo);
}
#[doc = "Reads up to \\a _nbytes bytes of data from \\a _stream."]
#[doc = "\\param      _stream The stream to read from."]
#[doc = "\\param[out] _ptr    The buffer to store the data in."]
#[doc = "\\param      _nbytes The maximum number of bytes to read."]
#[doc = "This function may return fewer, though it will not"]
#[doc = "return zero unless it reaches end-of-file."]
#[doc = "\\return The number of bytes successfully read, or a negative value on"]
#[doc = "error."]
pub type op_read_func = ::std::option::Option<
    unsafe extern "C" fn(
        _stream: *mut ::std::os::raw::c_void,
        _ptr: *mut ::std::os::raw::c_uchar,
        _nbytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "Sets the position indicator for \\a _stream."]
#[doc = "The new position, measured in bytes, is obtained by adding \\a _offset"]
#[doc = "bytes to the position specified by \\a _whence."]
#[doc = "If \\a _whence is set to <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or"]
#[doc = "<code>SEEK_END</code>, the offset is relative to the start of the stream,"]
#[doc = "the current position indicator, or end-of-file, respectively."]
#[doc = "\\retval 0  Success."]
#[doc = "\\retval -1 Seeking is not supported or an error occurred."]
#[doc = "<code>errno</code> need not be set."]
pub type op_seek_func = ::std::option::Option<
    unsafe extern "C" fn(
        _stream: *mut ::std::os::raw::c_void,
        _offset: opus_int64,
        _whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "Obtains the current value of the position indicator for \\a _stream."]
#[doc = "\\return The current position indicator."]
pub type op_tell_func =
    ::std::option::Option<unsafe extern "C" fn(_stream: *mut ::std::os::raw::c_void) -> opus_int64>;
#[doc = "Closes the underlying stream."]
#[doc = "\\retval 0   Success."]
#[doc = "\\retval EOF An error occurred."]
#[doc = "<code>errno</code> need not be set."]
pub type op_close_func = ::std::option::Option<
    unsafe extern "C" fn(_stream: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = "The callbacks used to access non-<code>FILE</code> stream resources."]
#[doc = "The function prototypes are basically the same as for the stdio functions"]
#[doc = "<code>fread()</code>, <code>fseek()</code>, <code>ftell()</code>, and"]
#[doc = "<code>fclose()</code>."]
#[doc = "The differences are that the <code>FILE *</code> arguments have been"]
#[doc = "replaced with a <code>void *</code>, which is to be used as a pointer to"]
#[doc = "whatever internal data these functions might need, that #seek and #tell"]
#[doc = "take and return 64-bit offsets, and that #seek <em>must</em> return -1 if"]
#[doc = "the stream is unseekable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusFileCallbacks {
    #[doc = "Used to read data from the stream."]
    #[doc = "This must not be <code>NULL</code>."]
    pub read: op_read_func,
    #[doc = "Used to seek in the stream."]
    #[doc = "This may be <code>NULL</code> if seeking is not implemented."]
    pub seek: op_seek_func,
    #[doc = "Used to return the current read position in the stream."]
    #[doc = "This may be <code>NULL</code> if seeking is not implemented."]
    pub tell: op_tell_func,
    #[doc = "Used to close the stream when the decoder is freed."]
    #[doc = "This may be <code>NULL</code> to leave the stream open."]
    pub close: op_close_func,
}
#[test]
fn bindgen_test_layout_OpusFileCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<OpusFileCallbacks>(),
        32usize,
        concat!("Size of: ", stringify!(OpusFileCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<OpusFileCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(OpusFileCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusFileCallbacks>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusFileCallbacks),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusFileCallbacks>())).seek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusFileCallbacks),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusFileCallbacks>())).tell as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusFileCallbacks),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpusFileCallbacks>())).close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OpusFileCallbacks),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    #[doc = "Opens a stream with <code>fopen()</code> and fills in a set of callbacks"]
    #[doc = "that can be used to access it."]
    #[doc = "This is useful to avoid writing your own portable 64-bit seeking wrappers,"]
    #[doc = "and also avoids cross-module linking issues on Windows, where a"]
    #[doc = "<code>FILE *</code> must be accessed by routines defined in the same module"]
    #[doc = "that opened it."]
    #[doc = "\\param[out] _cb   The callbacks to use for this file."]
    #[doc = "If there is an error opening the file, nothing will be"]
    #[doc = "filled in here."]
    #[doc = "\\param      _path The path to the file to open."]
    #[doc = "On Windows, this string must be UTF-8 (to allow access to"]
    #[doc = "files whose names cannot be represented in the current"]
    #[doc = "MBCS code page)."]
    #[doc = "All other systems use the native character encoding."]
    #[doc = "\\param      _mode The mode to open the file in."]
    #[doc = "\\return A stream handle to use with the callbacks, or <code>NULL</code> on"]
    #[doc = "error."]
    pub fn op_fopen(
        _cb: *mut OpusFileCallbacks,
        _path: *const ::std::os::raw::c_char,
        _mode: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Opens a stream with <code>fdopen()</code> and fills in a set of callbacks"]
    #[doc = "that can be used to access it."]
    #[doc = "This is useful to avoid writing your own portable 64-bit seeking wrappers,"]
    #[doc = "and also avoids cross-module linking issues on Windows, where a"]
    #[doc = "<code>FILE *</code> must be accessed by routines defined in the same module"]
    #[doc = "that opened it."]
    #[doc = "\\param[out] _cb   The callbacks to use for this file."]
    #[doc = "If there is an error opening the file, nothing will be"]
    #[doc = "filled in here."]
    #[doc = "\\param      _fd   The file descriptor to open."]
    #[doc = "\\param      _mode The mode to open the file in."]
    #[doc = "\\return A stream handle to use with the callbacks, or <code>NULL</code> on"]
    #[doc = "error."]
    pub fn op_fdopen(
        _cb: *mut OpusFileCallbacks,
        _fd: ::std::os::raw::c_int,
        _mode: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Opens a stream with <code>freopen()</code> and fills in a set of callbacks"]
    #[doc = "that can be used to access it."]
    #[doc = "This is useful to avoid writing your own portable 64-bit seeking wrappers,"]
    #[doc = "and also avoids cross-module linking issues on Windows, where a"]
    #[doc = "<code>FILE *</code> must be accessed by routines defined in the same module"]
    #[doc = "that opened it."]
    #[doc = "\\param[out] _cb     The callbacks to use for this file."]
    #[doc = "If there is an error opening the file, nothing will be"]
    #[doc = "filled in here."]
    #[doc = "\\param      _path   The path to the file to open."]
    #[doc = "On Windows, this string must be UTF-8 (to allow access"]
    #[doc = "to files whose names cannot be represented in the"]
    #[doc = "current MBCS code page)."]
    #[doc = "All other systems use the native character encoding."]
    #[doc = "\\param      _mode   The mode to open the file in."]
    #[doc = "\\param      _stream A stream previously returned by op_fopen(), op_fdopen(),"]
    #[doc = "or op_freopen()."]
    #[doc = "\\return A stream handle to use with the callbacks, or <code>NULL</code> on"]
    #[doc = "error."]
    pub fn op_freopen(
        _cb: *mut OpusFileCallbacks,
        _path: *const ::std::os::raw::c_char,
        _mode: *const ::std::os::raw::c_char,
        _stream: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Creates a stream that reads from the given block of memory."]
    #[doc = "This block of memory must contain the complete stream to decode."]
    #[doc = "This is useful for caching small streams (e.g., sound effects) in RAM."]
    #[doc = "\\param[out] _cb   The callbacks to use for this stream."]
    #[doc = "If there is an error creating the stream, nothing will be"]
    #[doc = "filled in here."]
    #[doc = "\\param      _data The block of memory to read from."]
    #[doc = "\\param      _size The size of the block of memory."]
    #[doc = "\\return A stream handle to use with the callbacks, or <code>NULL</code> on"]
    #[doc = "error."]
    pub fn op_mem_stream_create(
        _cb: *mut OpusFileCallbacks,
        _data: *const ::std::os::raw::c_uchar,
        _size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Creates a stream that reads from the given URL."]
    #[doc = "This function behaves identically to op_url_stream_create(), except that it"]
    #[doc = "takes a va_list instead of a variable number of arguments."]
    #[doc = "It does not call the <code>va_end</code> macro, and because it invokes the"]
    #[doc = "<code>va_arg</code> macro, the value of \\a _ap is undefined after the call."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    #[doc = "\\param[out]    _cb  The callbacks to use for this stream."]
    #[doc = "If there is an error creating the stream, nothing will"]
    #[doc = "be filled in here."]
    #[doc = "\\param         _url The URL to read from."]
    #[doc = "Currently only the <file:>, <http:>, and <https:>"]
    #[doc = "schemes are supported."]
    #[doc = "Both <http:> and <https:> may be disabled at compile"]
    #[doc = "time, in which case opening such URLs will always fail."]
    #[doc = "Currently this only supports URIs."]
    #[doc = "IRIs should be converted to UTF-8 and URL-escaped, with"]
    #[doc = "internationalized domain names encoded in punycode,"]
    #[doc = "before passing them to this function."]
    #[doc = "\\param[in,out] _ap  A list of the \\ref url_options \"optional flags\" to use."]
    #[doc = "This is a variable-length list of options terminated"]
    #[doc = "with <code>NULL</code>."]
    #[doc = "\\return A stream handle to use with the callbacks, or <code>NULL</code> on"]
    #[doc = "error."]
    pub fn op_url_stream_vcreate(
        _cb: *mut OpusFileCallbacks,
        _url: *const ::std::os::raw::c_char,
        _ap: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Creates a stream that reads from the given URL."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    #[doc = "\\param[out] _cb  The callbacks to use for this stream."]
    #[doc = "If there is an error creating the stream, nothing will be"]
    #[doc = "filled in here."]
    #[doc = "\\param      _url The URL to read from."]
    #[doc = "Currently only the <file:>, <http:>, and <https:> schemes"]
    #[doc = "are supported."]
    #[doc = "Both <http:> and <https:> may be disabled at compile time,"]
    #[doc = "in which case opening such URLs will always fail."]
    #[doc = "Currently this only supports URIs."]
    #[doc = "IRIs should be converted to UTF-8 and URL-escaped, with"]
    #[doc = "internationalized domain names encoded in punycode, before"]
    #[doc = "passing them to this function."]
    #[doc = "\\param      ...  The \\ref url_options \"optional flags\" to use."]
    #[doc = "This is a variable-length list of options terminated with"]
    #[doc = "<code>NULL</code>."]
    #[doc = "\\return A stream handle to use with the callbacks, or <code>NULL</code> on"]
    #[doc = "error."]
    pub fn op_url_stream_create(
        _cb: *mut OpusFileCallbacks,
        _url: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Test to see if this is an Opus stream."]
    #[doc = "For good results, you will need at least 57 bytes (for a pure Opus-only"]
    #[doc = "stream)."]
    #[doc = "Something like 512 bytes will give more reliable results for multiplexed"]
    #[doc = "streams."]
    #[doc = "This function is meant to be a quick-rejection filter."]
    #[doc = "Its purpose is not to guarantee that a stream is a valid Opus stream, but to"]
    #[doc = "ensure that it looks enough like Opus that it isn't going to be recognized"]
    #[doc = "as some other format (except possibly an Opus stream that is also"]
    #[doc = "multiplexed with other codecs, such as video)."]
    #[doc = "\\param[out] _head     The parsed ID header contents."]
    #[doc = "You may pass <code>NULL</code> if you do not need"]
    #[doc = "this information."]
    #[doc = "If the function fails, the contents of this structure"]
    #[doc = "remain untouched."]
    #[doc = "\\param _initial_data  An initial buffer of data from the start of the"]
    #[doc = "stream."]
    #[doc = "\\param _initial_bytes The number of bytes in \\a _initial_data."]
    #[doc = "\\return 0 if the data appears to be Opus, or a negative value on error."]
    #[doc = "\\retval #OP_FALSE      There was not enough data to tell if this was an Opus"]
    #[doc = "stream or not."]
    #[doc = "\\retval #OP_EFAULT     An internal memory allocation failed."]
    #[doc = "\\retval #OP_EIMPL      The stream used a feature that is not implemented,"]
    #[doc = "such as an unsupported channel family."]
    #[doc = "\\retval #OP_ENOTFORMAT If the data did not contain a recognizable ID"]
    #[doc = "header for an Opus stream."]
    #[doc = "\\retval #OP_EVERSION   If the version field signaled a version this library"]
    #[doc = "does not know how to parse."]
    #[doc = "\\retval #OP_EBADHEADER The ID header was not properly formatted or contained"]
    #[doc = "illegal values."]
    pub fn op_test(
        _head: *mut OpusHead,
        _initial_data: *const ::std::os::raw::c_uchar,
        _initial_bytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Open a stream from the given file path."]
    #[doc = "\\param      _path  The path to the file to open."]
    #[doc = "\\param[out] _error Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want the"]
    #[doc = "failure code."]
    #[doc = "The failure code will be #OP_EFAULT if the file could not"]
    #[doc = "be opened, or one of the other failure codes from"]
    #[doc = "op_open_callbacks() otherwise."]
    #[doc = "\\return A freshly opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_open_file(
        _path: *const ::std::os::raw::c_char,
        _error: *mut ::std::os::raw::c_int,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Open a stream from a memory buffer."]
    #[doc = "\\param      _data  The memory buffer to open."]
    #[doc = "\\param      _size  The number of bytes in the buffer."]
    #[doc = "\\param[out] _error Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want the"]
    #[doc = "failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure codes."]
    #[doc = "\\return A freshly opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_open_memory(
        _data: *const ::std::os::raw::c_uchar,
        _size: usize,
        _error: *mut ::std::os::raw::c_int,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Open a stream from a URL."]
    #[doc = "This function behaves identically to op_open_url(), except that it"]
    #[doc = "takes a va_list instead of a variable number of arguments."]
    #[doc = "It does not call the <code>va_end</code> macro, and because it invokes the"]
    #[doc = "<code>va_arg</code> macro, the value of \\a _ap is undefined after the call."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    #[doc = "\\param         _url   The URL to open."]
    #[doc = "Currently only the <file:>, <http:>, and <https:>"]
    #[doc = "schemes are supported."]
    #[doc = "Both <http:> and <https:> may be disabled at compile"]
    #[doc = "time, in which case opening such URLs will always"]
    #[doc = "fail."]
    #[doc = "Currently this only supports URIs."]
    #[doc = "IRIs should be converted to UTF-8 and URL-escaped,"]
    #[doc = "with internationalized domain names encoded in"]
    #[doc = "punycode, before passing them to this function."]
    #[doc = "\\param[out]    _error Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want"]
    #[doc = "the failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure"]
    #[doc = "codes."]
    #[doc = "\\param[in,out] _ap    A list of the \\ref url_options \"optional flags\" to"]
    #[doc = "use."]
    #[doc = "This is a variable-length list of options terminated"]
    #[doc = "with <code>NULL</code>."]
    #[doc = "\\return A freshly opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_vopen_url(
        _url: *const ::std::os::raw::c_char,
        _error: *mut ::std::os::raw::c_int,
        _ap: *mut __va_list_tag,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Open a stream from a URL."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    #[doc = "\\param      _url   The URL to open."]
    #[doc = "Currently only the <file:>, <http:>, and <https:> schemes"]
    #[doc = "are supported."]
    #[doc = "Both <http:> and <https:> may be disabled at compile"]
    #[doc = "time, in which case opening such URLs will always fail."]
    #[doc = "Currently this only supports URIs."]
    #[doc = "IRIs should be converted to UTF-8 and URL-escaped, with"]
    #[doc = "internationalized domain names encoded in punycode,"]
    #[doc = "before passing them to this function."]
    #[doc = "\\param[out] _error Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want the"]
    #[doc = "failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure codes."]
    #[doc = "\\param      ...    The \\ref url_options \"optional flags\" to use."]
    #[doc = "This is a variable-length list of options terminated with"]
    #[doc = "<code>NULL</code>."]
    #[doc = "\\return A freshly opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_open_url(
        _url: *const ::std::os::raw::c_char,
        _error: *mut ::std::os::raw::c_int,
        ...
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Open a stream using the given set of callbacks to access it."]
    #[doc = "\\param _stream        The stream to read from (e.g., a <code>FILE *</code>)."]
    #[doc = "This value will be passed verbatim as the first"]
    #[doc = "argument to all of the callbacks."]
    #[doc = "\\param _cb            The callbacks with which to access the stream."]
    #[doc = "<code><a href=\"#op_read_func\">read()</a></code> must"]
    #[doc = "be implemented."]
    #[doc = "<code><a href=\"#op_seek_func\">seek()</a></code> and"]
    #[doc = "<code><a href=\"#op_tell_func\">tell()</a></code> may"]
    #[doc = "be <code>NULL</code>, or may always return -1 to"]
    #[doc = "indicate a stream is unseekable, but if"]
    #[doc = "<code><a href=\"#op_seek_func\">seek()</a></code> is"]
    #[doc = "implemented and succeeds on a particular stream, then"]
    #[doc = "<code><a href=\"#op_tell_func\">tell()</a></code> must"]
    #[doc = "also."]
    #[doc = "<code><a href=\"#op_close_func\">close()</a></code> may"]
    #[doc = "be <code>NULL</code>, but if it is not, it will be"]
    #[doc = "called when the \\c OggOpusFile is destroyed by"]
    #[doc = "op_free()."]
    #[doc = "It will not be called if op_open_callbacks() fails"]
    #[doc = "with an error."]
    #[doc = "\\param _initial_data  An initial buffer of data from the start of the"]
    #[doc = "stream."]
    #[doc = "Applications can read some number of bytes from the"]
    #[doc = "start of the stream to help identify this as an Opus"]
    #[doc = "stream, and then provide them here to allow the"]
    #[doc = "stream to be opened, even if it is unseekable."]
    #[doc = "\\param _initial_bytes The number of bytes in \\a _initial_data."]
    #[doc = "If the stream is seekable, its current position (as"]
    #[doc = "reported by"]
    #[doc = "<code><a href=\"#opus_tell_func\">tell()</a></code>"]
    #[doc = "at the start of this function) must be equal to"]
    #[doc = "\\a _initial_bytes."]
    #[doc = "Otherwise, seeking to absolute positions will"]
    #[doc = "generate inconsistent results."]
    #[doc = "\\param[out] _error    Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want"]
    #[doc = "the failure code."]
    #[doc = "The failure code will be one of"]
    #[doc = "<dl>"]
    #[doc = "<dt>#OP_EREAD</dt>"]
    #[doc = "<dd>An underlying read, seek, or tell operation"]
    #[doc = "failed when it should have succeeded, or we failed"]
    #[doc = "to find data in the stream we had seen before.</dd>"]
    #[doc = "<dt>#OP_EFAULT</dt>"]
    #[doc = "<dd>There was a memory allocation failure, or an"]
    #[doc = "internal library error.</dd>"]
    #[doc = "<dt>#OP_EIMPL</dt>"]
    #[doc = "<dd>The stream used a feature that is not"]
    #[doc = "implemented, such as an unsupported channel"]
    #[doc = "family.</dd>"]
    #[doc = "<dt>#OP_EINVAL</dt>"]
    #[doc = "<dd><code><a href=\"#op_seek_func\">seek()</a></code>"]
    #[doc = "was implemented and succeeded on this source, but"]
    #[doc = "<code><a href=\"#op_tell_func\">tell()</a></code>"]
    #[doc = "did not, or the starting position indicator was"]
    #[doc = "not equal to \\a _initial_bytes.</dd>"]
    #[doc = "<dt>#OP_ENOTFORMAT</dt>"]
    #[doc = "<dd>The stream contained a link that did not have"]
    #[doc = "any logical Opus streams in it.</dd>"]
    #[doc = "<dt>#OP_EBADHEADER</dt>"]
    #[doc = "<dd>A required header packet was not properly"]
    #[doc = "formatted, contained illegal values, or was missing"]
    #[doc = "altogether.</dd>"]
    #[doc = "<dt>#OP_EVERSION</dt>"]
    #[doc = "<dd>An ID header contained an unrecognized version"]
    #[doc = "number.</dd>"]
    #[doc = "<dt>#OP_EBADLINK</dt>"]
    #[doc = "<dd>We failed to find data we had seen before after"]
    #[doc = "seeking.</dd>"]
    #[doc = "<dt>#OP_EBADTIMESTAMP</dt>"]
    #[doc = "<dd>The first or last timestamp in a link failed"]
    #[doc = "basic validity checks.</dd>"]
    #[doc = "</dl>"]
    #[doc = "\\return A freshly opened \\c OggOpusFile, or <code>NULL</code> on error."]
    #[doc = "<tt>libopusfile</tt> does <em>not</em> take ownership of the stream"]
    #[doc = "if the call fails."]
    #[doc = "The calling application is responsible for closing the stream if"]
    #[doc = "this call returns an error."]
    pub fn op_open_callbacks(
        _stream: *mut ::std::os::raw::c_void,
        _cb: *const OpusFileCallbacks,
        _initial_data: *const ::std::os::raw::c_uchar,
        _initial_bytes: usize,
        _error: *mut ::std::os::raw::c_int,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Partially open a stream from the given file path."]
    #[doc = "\\see op_test_callbacks"]
    #[doc = "\\param      _path  The path to the file to open."]
    #[doc = "\\param[out] _error Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want the"]
    #[doc = "failure code."]
    #[doc = "The failure code will be #OP_EFAULT if the file could not"]
    #[doc = "be opened, or one of the other failure codes from"]
    #[doc = "op_open_callbacks() otherwise."]
    #[doc = "\\return A partially opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_test_file(
        _path: *const ::std::os::raw::c_char,
        _error: *mut ::std::os::raw::c_int,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Partially open a stream from a memory buffer."]
    #[doc = "\\see op_test_callbacks"]
    #[doc = "\\param      _data  The memory buffer to open."]
    #[doc = "\\param      _size  The number of bytes in the buffer."]
    #[doc = "\\param[out] _error Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want the"]
    #[doc = "failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure codes."]
    #[doc = "\\return A partially opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_test_memory(
        _data: *const ::std::os::raw::c_uchar,
        _size: usize,
        _error: *mut ::std::os::raw::c_int,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Partially open a stream from a URL."]
    #[doc = "This function behaves identically to op_test_url(), except that it"]
    #[doc = "takes a va_list instead of a variable number of arguments."]
    #[doc = "It does not call the <code>va_end</code> macro, and because it invokes the"]
    #[doc = "<code>va_arg</code> macro, the value of \\a _ap is undefined after the call."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    #[doc = "\\see op_test_url"]
    #[doc = "\\see op_test_callbacks"]
    #[doc = "\\param         _url    The URL to open."]
    #[doc = "Currently only the <file:>, <http:>, and <https:>"]
    #[doc = "schemes are supported."]
    #[doc = "Both <http:> and <https:> may be disabled at compile"]
    #[doc = "time, in which case opening such URLs will always"]
    #[doc = "fail."]
    #[doc = "Currently this only supports URIs."]
    #[doc = "IRIs should be converted to UTF-8 and URL-escaped,"]
    #[doc = "with internationalized domain names encoded in"]
    #[doc = "punycode, before passing them to this function."]
    #[doc = "\\param[out]    _error  Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want"]
    #[doc = "the failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure"]
    #[doc = "codes."]
    #[doc = "\\param[in,out] _ap     A list of the \\ref url_options \"optional flags\" to"]
    #[doc = "use."]
    #[doc = "This is a variable-length list of options terminated"]
    #[doc = "with <code>NULL</code>."]
    #[doc = "\\return A partially opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_vtest_url(
        _url: *const ::std::os::raw::c_char,
        _error: *mut ::std::os::raw::c_int,
        _ap: *mut __va_list_tag,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Partially open a stream from a URL."]
    #[doc = "\\note If you use this function, you must link against <tt>libopusurl</tt>."]
    #[doc = "\\see op_test_callbacks"]
    #[doc = "\\param      _url    The URL to open."]
    #[doc = "Currently only the <file:>, <http:>, and <https:>"]
    #[doc = "schemes are supported."]
    #[doc = "Both <http:> and <https:> may be disabled at compile"]
    #[doc = "time, in which case opening such URLs will always fail."]
    #[doc = "Currently this only supports URIs."]
    #[doc = "IRIs should be converted to UTF-8 and URL-escaped, with"]
    #[doc = "internationalized domain names encoded in punycode,"]
    #[doc = "before passing them to this function."]
    #[doc = "\\param[out] _error  Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want the"]
    #[doc = "failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure"]
    #[doc = "codes."]
    #[doc = "\\param      ...     The \\ref url_options \"optional flags\" to use."]
    #[doc = "This is a variable-length list of options terminated"]
    #[doc = "with <code>NULL</code>."]
    #[doc = "\\return A partially opened \\c OggOpusFile, or <code>NULL</code> on error."]
    pub fn op_test_url(
        _url: *const ::std::os::raw::c_char,
        _error: *mut ::std::os::raw::c_int,
        ...
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Partially open a stream using the given set of callbacks to access it."]
    #[doc = "This tests for Opusness and loads the headers for the first link."]
    #[doc = "It does not seek (although it tests for seekability)."]
    #[doc = "You can query a partially open stream for the few pieces of basic"]
    #[doc = "information returned by op_serialno(), op_channel_count(), op_head(), and"]
    #[doc = "op_tags() (but only for the first link)."]
    #[doc = "You may also determine if it is seekable via a call to op_seekable()."]
    #[doc = "You cannot read audio from the stream, seek, get the size or duration,"]
    #[doc = "get information from links other than the first one, or even get the total"]
    #[doc = "number of links until you finish opening the stream with op_test_open()."]
    #[doc = "If you do not need to do any of these things, you can dispose of it with"]
    #[doc = "op_free() instead."]
    #[doc = ""]
    #[doc = "This function is provided mostly to simplify porting existing code that used"]
    #[doc = "<tt>libvorbisfile</tt>."]
    #[doc = "For new code, you are likely better off using op_test() instead, which"]
    #[doc = "is less resource-intensive, requires less data to succeed, and imposes a"]
    #[doc = "hard limit on the amount of data it examines (important for unseekable"]
    #[doc = "streams, where all such data must be buffered until you are sure of the"]
    #[doc = "stream type)."]
    #[doc = "\\param _stream        The stream to read from (e.g., a <code>FILE *</code>)."]
    #[doc = "This value will be passed verbatim as the first"]
    #[doc = "argument to all of the callbacks."]
    #[doc = "\\param _cb            The callbacks with which to access the stream."]
    #[doc = "<code><a href=\"#op_read_func\">read()</a></code> must"]
    #[doc = "be implemented."]
    #[doc = "<code><a href=\"#op_seek_func\">seek()</a></code> and"]
    #[doc = "<code><a href=\"#op_tell_func\">tell()</a></code> may"]
    #[doc = "be <code>NULL</code>, or may always return -1 to"]
    #[doc = "indicate a stream is unseekable, but if"]
    #[doc = "<code><a href=\"#op_seek_func\">seek()</a></code> is"]
    #[doc = "implemented and succeeds on a particular stream, then"]
    #[doc = "<code><a href=\"#op_tell_func\">tell()</a></code> must"]
    #[doc = "also."]
    #[doc = "<code><a href=\"#op_close_func\">close()</a></code> may"]
    #[doc = "be <code>NULL</code>, but if it is not, it will be"]
    #[doc = "called when the \\c OggOpusFile is destroyed by"]
    #[doc = "op_free()."]
    #[doc = "It will not be called if op_open_callbacks() fails"]
    #[doc = "with an error."]
    #[doc = "\\param _initial_data  An initial buffer of data from the start of the"]
    #[doc = "stream."]
    #[doc = "Applications can read some number of bytes from the"]
    #[doc = "start of the stream to help identify this as an Opus"]
    #[doc = "stream, and then provide them here to allow the"]
    #[doc = "stream to be tested more thoroughly, even if it is"]
    #[doc = "unseekable."]
    #[doc = "\\param _initial_bytes The number of bytes in \\a _initial_data."]
    #[doc = "If the stream is seekable, its current position (as"]
    #[doc = "reported by"]
    #[doc = "<code><a href=\"#opus_tell_func\">tell()</a></code>"]
    #[doc = "at the start of this function) must be equal to"]
    #[doc = "\\a _initial_bytes."]
    #[doc = "Otherwise, seeking to absolute positions will"]
    #[doc = "generate inconsistent results."]
    #[doc = "\\param[out] _error    Returns 0 on success, or a failure code on error."]
    #[doc = "You may pass in <code>NULL</code> if you don't want"]
    #[doc = "the failure code."]
    #[doc = "See op_open_callbacks() for a full list of failure"]
    #[doc = "codes."]
    #[doc = "\\return A partially opened \\c OggOpusFile, or <code>NULL</code> on error."]
    #[doc = "<tt>libopusfile</tt> does <em>not</em> take ownership of the stream"]
    #[doc = "if the call fails."]
    #[doc = "The calling application is responsible for closing the stream if"]
    #[doc = "this call returns an error."]
    pub fn op_test_callbacks(
        _stream: *mut ::std::os::raw::c_void,
        _cb: *const OpusFileCallbacks,
        _initial_data: *const ::std::os::raw::c_uchar,
        _initial_bytes: usize,
        _error: *mut ::std::os::raw::c_int,
    ) -> *mut OggOpusFile;
}
extern "C" {
    #[doc = "Finish opening a stream partially opened with op_test_callbacks() or one of"]
    #[doc = "the associated convenience functions."]
    #[doc = "If this function fails, you are still responsible for freeing the"]
    #[doc = "\\c OggOpusFile with op_free()."]
    #[doc = "\\param _of The \\c OggOpusFile to finish opening."]
    #[doc = "\\return 0 on success, or a negative value on error."]
    #[doc = "\\retval #OP_EREAD         An underlying read, seek, or tell operation failed"]
    #[doc = "when it should have succeeded."]
    #[doc = "\\retval #OP_EFAULT        There was a memory allocation failure, or an"]
    #[doc = "internal library error."]
    #[doc = "\\retval #OP_EIMPL         The stream used a feature that is not implemented,"]
    #[doc = "such as an unsupported channel family."]
    #[doc = "\\retval #OP_EINVAL        The stream was not partially opened with"]
    #[doc = "op_test_callbacks() or one of the associated"]
    #[doc = "convenience functions."]
    #[doc = "\\retval #OP_ENOTFORMAT    The stream contained a link that did not have any"]
    #[doc = "logical Opus streams in it."]
    #[doc = "\\retval #OP_EBADHEADER    A required header packet was not properly"]
    #[doc = "formatted, contained illegal values, or was"]
    #[doc = "missing altogether."]
    #[doc = "\\retval #OP_EVERSION      An ID header contained an unrecognized version"]
    #[doc = "number."]
    #[doc = "\\retval #OP_EBADLINK      We failed to find data we had seen before after"]
    #[doc = "seeking."]
    #[doc = "\\retval #OP_EBADTIMESTAMP The first or last timestamp in a link failed basic"]
    #[doc = "validity checks."]
    pub fn op_test_open(_of: *mut OggOpusFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Release all memory used by an \\c OggOpusFile."]
    #[doc = "\\param _of The \\c OggOpusFile to free."]
    pub fn op_free(_of: *mut OggOpusFile);
}
extern "C" {
    #[doc = "Returns whether or not the stream being read is seekable."]
    #[doc = "This is true if"]
    #[doc = "<ol>"]
    #[doc = "<li>The <code><a href=\"#op_seek_func\">seek()</a></code> and"]
    #[doc = "<code><a href=\"#op_tell_func\">tell()</a></code> callbacks are both"]
    #[doc = "non-<code>NULL</code>,</li>"]
    #[doc = "<li>The <code><a href=\"#op_seek_func\">seek()</a></code> callback was"]
    #[doc = "successfully executed at least once, and</li>"]
    #[doc = "<li>The <code><a href=\"#op_tell_func\">tell()</a></code> callback was"]
    #[doc = "successfully able to report the position indicator afterwards.</li>"]
    #[doc = "</ol>"]
    #[doc = "This function may be called on partially-opened streams."]
    #[doc = "\\param _of The \\c OggOpusFile whose seekable status is to be returned."]
    #[doc = "\\return A non-zero value if seekable, and 0 if unseekable."]
    pub fn op_seekable(_of: *const OggOpusFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the number of links in this chained stream."]
    #[doc = "This function may be called on partially-opened streams, but it will always"]
    #[doc = "return 1."]
    #[doc = "The actual number of links is not known until the stream is fully opened."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the link count."]
    #[doc = "\\return For fully-open seekable streams, this returns the total number of"]
    #[doc = "links in the whole stream, which will be at least 1."]
    #[doc = "For partially-open or unseekable streams, this always returns 1."]
    pub fn op_link_count(_of: *const OggOpusFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the serial number of the given link in a (possibly-chained) Ogg Opus"]
    #[doc = "stream."]
    #[doc = "This function may be called on partially-opened streams, but it will always"]
    #[doc = "return the serial number of the Opus stream in the first link."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the serial number."]
    #[doc = "\\param _li The index of the link whose serial number should be retrieved."]
    #[doc = "Use a negative number to get the serial number of the current"]
    #[doc = "link."]
    #[doc = "\\return The serial number of the given link."]
    #[doc = "If \\a _li is greater than the total number of links, this returns"]
    #[doc = "the serial number of the last link."]
    #[doc = "If the stream is not seekable, this always returns the serial number"]
    #[doc = "of the current link."]
    pub fn op_serialno(_of: *const OggOpusFile, _li: ::std::os::raw::c_int) -> opus_uint32;
}
extern "C" {
    #[doc = "Get the channel count of the given link in a (possibly-chained) Ogg Opus"]
    #[doc = "stream."]
    #[doc = "This is equivalent to <code>op_head(_of,_li)->channel_count</code>, but"]
    #[doc = "is provided for convenience."]
    #[doc = "This function may be called on partially-opened streams, but it will always"]
    #[doc = "return the channel count of the Opus stream in the first link."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the channel count."]
    #[doc = "\\param _li The index of the link whose channel count should be retrieved."]
    #[doc = "Use a negative number to get the channel count of the current"]
    #[doc = "link."]
    #[doc = "\\return The channel count of the given link."]
    #[doc = "If \\a _li is greater than the total number of links, this returns"]
    #[doc = "the channel count of the last link."]
    #[doc = "If the stream is not seekable, this always returns the channel count"]
    #[doc = "of the current link."]
    pub fn op_channel_count(
        _of: *const OggOpusFile,
        _li: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the total (compressed) size of the stream, or of an individual link in"]
    #[doc = "a (possibly-chained) Ogg Opus stream, including all headers and Ogg muxing"]
    #[doc = "overhead."]
    #[doc = "\\warning If the Opus stream (or link) is concurrently multiplexed with other"]
    #[doc = "logical streams (e.g., video), this returns the size of the entire stream"]
    #[doc = "(or link), not just the number of bytes in the first logical Opus stream."]
    #[doc = "Returning the latter would require scanning the entire file."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the compressed size."]
    #[doc = "\\param _li The index of the link whose compressed size should be computed."]
    #[doc = "Use a negative number to get the compressed size of the entire"]
    #[doc = "stream."]
    #[doc = "\\return The compressed size of the entire stream if \\a _li is negative, the"]
    #[doc = "compressed size of link \\a _li if it is non-negative, or a negative"]
    #[doc = "value on error."]
    #[doc = "The compressed size of the entire stream may be smaller than that"]
    #[doc = "of the underlying stream if trailing garbage was detected in the"]
    #[doc = "file."]
    #[doc = "\\retval #OP_EINVAL The stream is not seekable (so we can't know the length),"]
    #[doc = "\\a _li wasn't less than the total number of links in"]
    #[doc = "the stream, or the stream was only partially open."]
    pub fn op_raw_total(_of: *const OggOpusFile, _li: ::std::os::raw::c_int) -> opus_int64;
}
extern "C" {
    #[doc = "Get the total PCM length (number of samples at 48 kHz) of the stream, or of"]
    #[doc = "an individual link in a (possibly-chained) Ogg Opus stream."]
    #[doc = "Users looking for <code>op_time_total()</code> should use op_pcm_total()"]
    #[doc = "instead."]
    #[doc = "Because timestamps in Opus are fixed at 48 kHz, there is no need for a"]
    #[doc = "separate function to convert this to seconds (and leaving it out avoids"]
    #[doc = "introducing floating point to the API, for those that wish to avoid it)."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the PCM offset."]
    #[doc = "\\param _li The index of the link whose PCM length should be computed."]
    #[doc = "Use a negative number to get the PCM length of the entire stream."]
    #[doc = "\\return The PCM length of the entire stream if \\a _li is negative, the PCM"]
    #[doc = "length of link \\a _li if it is non-negative, or a negative value on"]
    #[doc = "error."]
    #[doc = "\\retval #OP_EINVAL The stream is not seekable (so we can't know the length),"]
    #[doc = "\\a _li wasn't less than the total number of links in"]
    #[doc = "the stream, or the stream was only partially open."]
    pub fn op_pcm_total(_of: *const OggOpusFile, _li: ::std::os::raw::c_int) -> ogg_int64_t;
}
extern "C" {
    #[doc = "Get the ID header information for the given link in a (possibly chained) Ogg"]
    #[doc = "Opus stream."]
    #[doc = "This function may be called on partially-opened streams, but it will always"]
    #[doc = "return the ID header information of the Opus stream in the first link."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the ID header"]
    #[doc = "information."]
    #[doc = "\\param _li The index of the link whose ID header information should be"]
    #[doc = "retrieved."]
    #[doc = "Use a negative number to get the ID header information of the"]
    #[doc = "current link."]
    #[doc = "For an unseekable stream, \\a _li is ignored, and the ID header"]
    #[doc = "information for the current link is always returned, if"]
    #[doc = "available."]
    #[doc = "\\return The contents of the ID header for the given link."]
    pub fn op_head(_of: *const OggOpusFile, _li: ::std::os::raw::c_int) -> *const OpusHead;
}
extern "C" {
    #[doc = "Get the comment header information for the given link in a (possibly"]
    #[doc = "chained) Ogg Opus stream."]
    #[doc = "This function may be called on partially-opened streams, but it will always"]
    #[doc = "return the tags from the Opus stream in the first link."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the comment header"]
    #[doc = "information."]
    #[doc = "\\param _li The index of the link whose comment header information should be"]
    #[doc = "retrieved."]
    #[doc = "Use a negative number to get the comment header information of"]
    #[doc = "the current link."]
    #[doc = "For an unseekable stream, \\a _li is ignored, and the comment"]
    #[doc = "header information for the current link is always returned, if"]
    #[doc = "available."]
    #[doc = "\\return The contents of the comment header for the given link, or"]
    #[doc = "<code>NULL</code> if this is an unseekable stream that encountered"]
    #[doc = "an invalid link."]
    pub fn op_tags(_of: *const OggOpusFile, _li: ::std::os::raw::c_int) -> *const OpusTags;
}
extern "C" {
    #[doc = "Retrieve the index of the current link."]
    #[doc = "This is the link that produced the data most recently read by"]
    #[doc = "op_read_float() or its associated functions, or, after a seek, the link"]
    #[doc = "that the seek target landed in."]
    #[doc = "Reading more data may advance the link index (even on the first read after a"]
    #[doc = "seek)."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the current link index."]
    #[doc = "\\return The index of the current link on success, or a negative value on"]
    #[doc = "failure."]
    #[doc = "For seekable streams, this is a number between 0 (inclusive) and the"]
    #[doc = "value returned by op_link_count() (exclusive)."]
    #[doc = "For unseekable streams, this value starts at 0 and increments by one"]
    #[doc = "each time a new link is encountered (even though op_link_count()"]
    #[doc = "always returns 1)."]
    #[doc = "\\retval #OP_EINVAL The stream was only partially open."]
    pub fn op_current_link(_of: *const OggOpusFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Computes the bitrate of the stream, or of an individual link in a"]
    #[doc = "(possibly-chained) Ogg Opus stream."]
    #[doc = "The stream must be seekable to compute the bitrate."]
    #[doc = "For unseekable streams, use op_bitrate_instant() to get periodic estimates."]
    #[doc = "\\warning If the Opus stream (or link) is concurrently multiplexed with other"]
    #[doc = "logical streams (e.g., video), this uses the size of the entire stream (or"]
    #[doc = "link) to compute the bitrate, not just the number of bytes in the first"]
    #[doc = "logical Opus stream."]
    #[doc = "Returning the latter requires scanning the entire file, but this may be done"]
    #[doc = "by decoding the whole file and calling op_bitrate_instant() once at the"]
    #[doc = "end."]
    #[doc = "Install a trivial decoding callback with op_set_decode_callback() if you"]
    #[doc = "wish to skip actual decoding during this process."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the bitrate."]
    #[doc = "\\param _li The index of the link whose bitrate should be computed."]
    #[doc = "Use a negative number to get the bitrate of the whole stream."]
    #[doc = "\\return The bitrate on success, or a negative value on error."]
    #[doc = "\\retval #OP_EINVAL The stream was only partially open, the stream was not"]
    #[doc = "seekable, or \\a _li was larger than the number of"]
    #[doc = "links."]
    pub fn op_bitrate(_of: *const OggOpusFile, _li: ::std::os::raw::c_int) -> opus_int32;
}
extern "C" {
    #[doc = "Compute the instantaneous bitrate, measured as the ratio of bits to playable"]
    #[doc = "samples decoded since a) the last call to op_bitrate_instant(), b) the last"]
    #[doc = "seek, or c) the start of playback, whichever was most recent."]
    #[doc = "This will spike somewhat after a seek or at the start/end of a chain"]
    #[doc = "boundary, as pre-skip, pre-roll, and end-trimming causes samples to be"]
    #[doc = "decoded but not played."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the bitrate."]
    #[doc = "\\return The bitrate, in bits per second, or a negative value on error."]
    #[doc = "\\retval #OP_FALSE  No data has been decoded since any of the events"]
    #[doc = "described above."]
    #[doc = "\\retval #OP_EINVAL The stream was only partially open."]
    pub fn op_bitrate_instant(_of: *mut OggOpusFile) -> opus_int32;
}
extern "C" {
    #[doc = "Obtain the current value of the position indicator for \\a _of."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the position indicator."]
    #[doc = "\\return The byte position that is currently being read from."]
    #[doc = "\\retval #OP_EINVAL The stream was only partially open."]
    pub fn op_raw_tell(_of: *const OggOpusFile) -> opus_int64;
}
extern "C" {
    #[doc = "Obtain the PCM offset of the next sample to be read."]
    #[doc = "If the stream is not properly timestamped, this might not increment by the"]
    #[doc = "proper amount between reads, or even return monotonically increasing"]
    #[doc = "values."]
    #[doc = "\\param _of The \\c OggOpusFile from which to retrieve the PCM offset."]
    #[doc = "\\return The PCM offset of the next sample to be read."]
    #[doc = "\\retval #OP_EINVAL The stream was only partially open."]
    pub fn op_pcm_tell(_of: *const OggOpusFile) -> ogg_int64_t;
}
extern "C" {
    #[doc = "Seek to a byte offset relative to the <b>compressed</b> data."]
    #[doc = "This also scans packets to update the PCM cursor."]
    #[doc = "It will cross a logical bitstream boundary, but only if it can't get any"]
    #[doc = "packets out of the tail of the link to which it seeks."]
    #[doc = "\\param _of          The \\c OggOpusFile in which to seek."]
    #[doc = "\\param _byte_offset The byte position to seek to."]
    #[doc = "This must be between 0 and #op_raw_total(\\a _of,\\c -1)"]
    #[doc = "(inclusive)."]
    #[doc = "\\return 0 on success, or a negative error code on failure."]
    #[doc = "\\retval #OP_EREAD    The underlying seek operation failed."]
    #[doc = "\\retval #OP_EINVAL   The stream was only partially open, or the target was"]
    #[doc = "outside the valid range for the stream."]
    #[doc = "\\retval #OP_ENOSEEK  This stream is not seekable."]
    #[doc = "\\retval #OP_EBADLINK Failed to initialize a decoder for a stream for an"]
    #[doc = "unknown reason."]
    pub fn op_raw_seek(_of: *mut OggOpusFile, _byte_offset: opus_int64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Seek to the specified PCM offset, such that decoding will begin at exactly"]
    #[doc = "the requested position."]
    #[doc = "\\param _of         The \\c OggOpusFile in which to seek."]
    #[doc = "\\param _pcm_offset The PCM offset to seek to."]
    #[doc = "This is in samples at 48 kHz relative to the start of the"]
    #[doc = "stream."]
    #[doc = "\\return 0 on success, or a negative value on error."]
    #[doc = "\\retval #OP_EREAD    An underlying read or seek operation failed."]
    #[doc = "\\retval #OP_EINVAL   The stream was only partially open, or the target was"]
    #[doc = "outside the valid range for the stream."]
    #[doc = "\\retval #OP_ENOSEEK  This stream is not seekable."]
    #[doc = "\\retval #OP_EBADLINK We failed to find data we had seen before, or the"]
    #[doc = "bitstream structure was sufficiently malformed that"]
    #[doc = "seeking to the target destination was impossible."]
    pub fn op_pcm_seek(_of: *mut OggOpusFile, _pcm_offset: ogg_int64_t) -> ::std::os::raw::c_int;
}
#[doc = "Called to decode an Opus packet."]
#[doc = "This should invoke the functional equivalent of opus_multistream_decode() or"]
#[doc = "opus_multistream_decode_float(), except that it returns 0 on success"]
#[doc = "instead of the number of decoded samples (which is known a priori)."]
#[doc = "\\param _ctx       The application-provided callback context."]
#[doc = "\\param _decoder   The decoder to use to decode the packet."]
#[doc = "\\param[out] _pcm  The buffer to decode into."]
#[doc = "This will always have enough room for \\a _nchannels of"]
#[doc = "\\a _nsamples samples, which should be placed into this"]
#[doc = "buffer interleaved."]
#[doc = "\\param _op        The packet to decode."]
#[doc = "This will always have its granule position set to a valid"]
#[doc = "value."]
#[doc = "\\param _nsamples  The number of samples expected from the packet."]
#[doc = "\\param _nchannels The number of channels expected from the packet."]
#[doc = "\\param _format    The desired sample output format."]
#[doc = "This is either #OP_DEC_FORMAT_SHORT or"]
#[doc = "#OP_DEC_FORMAT_FLOAT."]
#[doc = "\\param _li        The index of the link from which this packet was decoded."]
#[doc = "\\return A non-negative value on success, or a negative value on error."]
#[doc = "Any error codes should be the same as those returned by"]
#[doc = "opus_multistream_decode() or opus_multistream_decode_float()."]
#[doc = "Success codes are as follows:"]
#[doc = "\\retval 0                   Decoding was successful."]
#[doc = "The application has filled the buffer with"]
#[doc = "exactly <code>\\a _nsamples*\\a"]
#[doc = "_nchannels</code> samples in the requested"]
#[doc = "format."]
#[doc = "\\retval #OP_DEC_USE_DEFAULT No decoding was done."]
#[doc = "<tt>libopusfile</tt> should do the decoding"]
#[doc = "by itself instead."]
pub type op_decode_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        _ctx: *mut ::std::os::raw::c_void,
        _decoder: *mut OpusMSDecoder,
        _pcm: *mut ::std::os::raw::c_void,
        _op: *const ogg_packet,
        _nsamples: ::std::os::raw::c_int,
        _nchannels: ::std::os::raw::c_int,
        _format: ::std::os::raw::c_int,
        _li: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "Sets the packet decode callback function."]
    #[doc = "If set, this is called once for each packet that needs to be decoded."]
    #[doc = "This can be used by advanced applications to do additional processing on the"]
    #[doc = "compressed or uncompressed data."]
    #[doc = "For example, an application might save the final entropy coder state for"]
    #[doc = "debugging and testing purposes, or it might apply additional filters"]
    #[doc = "before the downmixing, dithering, or soft-clipping performed by"]
    #[doc = "<tt>libopusfile</tt>, so long as these filters do not introduce any"]
    #[doc = "latency."]
    #[doc = ""]
    #[doc = "A call to this function is no guarantee that the audio will eventually be"]
    #[doc = "delivered to the application."]
    #[doc = "<tt>libopusfile</tt> may discard some or all of the decoded audio data"]
    #[doc = "(i.e., at the beginning or end of a link, or after a seek), however the"]
    #[doc = "callback is still required to provide all of it."]
    #[doc = "\\param _of        The \\c OggOpusFile on which to set the decode callback."]
    #[doc = "\\param _decode_cb The callback function to call."]
    #[doc = "This may be <code>NULL</code> to disable calling the"]
    #[doc = "callback."]
    #[doc = "\\param _ctx       The application-provided context pointer to pass to the"]
    #[doc = "callback on each call."]
    pub fn op_set_decode_callback(
        _of: *mut OggOpusFile,
        _decode_cb: op_decode_cb_func,
        _ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Sets the gain to be used for decoded output."]
    #[doc = "By default, the gain in the header is applied with no additional offset."]
    #[doc = "The total gain (including header gain and/or track gain, if applicable, and"]
    #[doc = "this offset), will be clamped to [-32768,32767]/256 dB."]
    #[doc = "This is more than enough to saturate or underflow 16-bit PCM."]
    #[doc = "\\note The new gain will not be applied to any already buffered, decoded"]
    #[doc = "output."]
    #[doc = "This means you cannot change it sample-by-sample, as at best it will be"]
    #[doc = "updated packet-by-packet."]
    #[doc = "It is meant for setting a target volume level, rather than applying smooth"]
    #[doc = "fades, etc."]
    #[doc = "\\param _of             The \\c OggOpusFile on which to set the gain offset."]
    #[doc = "\\param _gain_type      One of #OP_HEADER_GAIN, #OP_ALBUM_GAIN,"]
    #[doc = "#OP_TRACK_GAIN, or #OP_ABSOLUTE_GAIN."]
    #[doc = "\\param _gain_offset_q8 The gain offset to apply, in 1/256ths of a dB."]
    #[doc = "\\return 0 on success or a negative value on error."]
    #[doc = "\\retval #OP_EINVAL The \\a _gain_type was unrecognized."]
    pub fn op_set_gain_offset(
        _of: *mut OggOpusFile,
        _gain_type: ::std::os::raw::c_int,
        _gain_offset_q8: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Sets whether or not dithering is enabled for 16-bit decoding."]
    #[doc = "By default, when <tt>libopusfile</tt> is compiled to use floating-point"]
    #[doc = "internally, calling op_read() or op_read_stereo() will first decode to"]
    #[doc = "float, and then convert to fixed-point using noise-shaping dithering."]
    #[doc = "This flag can be used to disable that dithering."]
    #[doc = "When the application uses op_read_float() or op_read_float_stereo(), or when"]
    #[doc = "the library has been compiled to decode directly to fixed point, this flag"]
    #[doc = "has no effect."]
    #[doc = "\\param _of      The \\c OggOpusFile on which to enable or disable dithering."]
    #[doc = "\\param _enabled A non-zero value to enable dithering, or 0 to disable it."]
    pub fn op_set_dither_enabled(_of: *mut OggOpusFile, _enabled: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "Reads more samples from the stream."]
    #[doc = "\\note Although \\a _buf_size must indicate the total number of values that"]
    #[doc = "can be stored in \\a _pcm, the return value is the number of samples"]
    #[doc = "<em>per channel</em>."]
    #[doc = "This is done because"]
    #[doc = "<ol>"]
    #[doc = "<li>The channel count cannot be known a priori (reading more samples might"]
    #[doc = "advance us into the next link, with a different channel count), so"]
    #[doc = "\\a _buf_size cannot also be in units of samples per channel,</li>"]
    #[doc = "<li>Returning the samples per channel matches the <code>libopus</code> API"]
    #[doc = "as closely as we're able,</li>"]
    #[doc = "<li>Returning the total number of values instead of samples per channel"]
    #[doc = "would mean the caller would need a division to compute the samples per"]
    #[doc = "channel, and might worry about the possibility of getting back samples"]
    #[doc = "for some channels and not others, and</li>"]
    #[doc = "<li>This approach is relatively fool-proof: if an application passes too"]
    #[doc = "small a value to \\a _buf_size, they will simply get fewer samples back,"]
    #[doc = "and if they assume the return value is the total number of values, then"]
    #[doc = "they will simply read too few (rather than reading too many and going"]
    #[doc = "off the end of the buffer).</li>"]
    #[doc = "</ol>"]
    #[doc = "\\param      _of       The \\c OggOpusFile from which to read."]
    #[doc = "\\param[out] _pcm      A buffer in which to store the output PCM samples, as"]
    #[doc = "signed native-endian 16-bit values at 48&nbsp;kHz"]
    #[doc = "with a nominal range of <code>[-32768,32767)</code>."]
    #[doc = "Multiple channels are interleaved using the"]
    #[doc = "<a href=\"http://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-800004.3.9\">Vorbis"]
    #[doc = "channel ordering</a>."]
    #[doc = "This must have room for at least \\a _buf_size values."]
    #[doc = "\\param      _buf_size The number of values that can be stored in \\a _pcm."]
    #[doc = "It is recommended that this be large enough for at"]
    #[doc = "least 120 ms of data at 48 kHz per channel (5760"]
    #[doc = "values per channel)."]
    #[doc = "Smaller buffers will simply return less data, possibly"]
    #[doc = "consuming more memory to buffer the data internally."]
    #[doc = "<tt>libopusfile</tt> may return less data than"]
    #[doc = "requested."]
    #[doc = "If so, there is no guarantee that the remaining data"]
    #[doc = "in \\a _pcm will be unmodified."]
    #[doc = "\\param[out] _li       The index of the link this data was decoded from."]
    #[doc = "You may pass <code>NULL</code> if you do not need this"]
    #[doc = "information."]
    #[doc = "If this function fails (returning a negative value),"]
    #[doc = "this parameter is left unset."]
    #[doc = "\\return The number of samples read per channel on success, or a negative"]
    #[doc = "value on failure."]
    #[doc = "The channel count can be retrieved on success by calling"]
    #[doc = "<code>op_head(_of,*_li)</code>."]
    #[doc = "The number of samples returned may be 0 if the buffer was too small"]
    #[doc = "to store even a single sample for all channels, or if end-of-file"]
    #[doc = "was reached."]
    #[doc = "The list of possible failure codes follows."]
    #[doc = "Most of them can only be returned by unseekable, chained streams"]
    #[doc = "that encounter a new link."]
    #[doc = "\\retval #OP_HOLE          There was a hole in the data, and some samples"]
    #[doc = "may have been skipped."]
    #[doc = "Call this function again to continue decoding"]
    #[doc = "past the hole."]
    #[doc = "\\retval #OP_EREAD         An underlying read operation failed."]
    #[doc = "This may signal a truncation attack from an"]
    #[doc = "<https:> source."]
    #[doc = "\\retval #OP_EFAULT        An internal memory allocation failed."]
    #[doc = "\\retval #OP_EIMPL         An unseekable stream encountered a new link that"]
    #[doc = "used a feature that is not implemented, such as"]
    #[doc = "an unsupported channel family."]
    #[doc = "\\retval #OP_EINVAL        The stream was only partially open."]
    #[doc = "\\retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that"]
    #[doc = "did not have any logical Opus streams in it."]
    #[doc = "\\retval #OP_EBADHEADER    An unseekable stream encountered a new link with a"]
    #[doc = "required header packet that was not properly"]
    #[doc = "formatted, contained illegal values, or was"]
    #[doc = "missing altogether."]
    #[doc = "\\retval #OP_EVERSION      An unseekable stream encountered a new link with"]
    #[doc = "an ID header that contained an unrecognized"]
    #[doc = "version number."]
    #[doc = "\\retval #OP_EBADPACKET    Failed to properly decode the next packet."]
    #[doc = "\\retval #OP_EBADLINK      We failed to find data we had seen before."]
    #[doc = "\\retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with"]
    #[doc = "a starting timestamp that failed basic validity"]
    #[doc = "checks."]
    pub fn op_read(
        _of: *mut OggOpusFile,
        _pcm: *mut opus_int16,
        _buf_size: ::std::os::raw::c_int,
        _li: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Reads more samples from the stream."]
    #[doc = "\\note Although \\a _buf_size must indicate the total number of values that"]
    #[doc = "can be stored in \\a _pcm, the return value is the number of samples"]
    #[doc = "<em>per channel</em>."]
    #[doc = "<ol>"]
    #[doc = "<li>The channel count cannot be known a priori (reading more samples might"]
    #[doc = "advance us into the next link, with a different channel count), so"]
    #[doc = "\\a _buf_size cannot also be in units of samples per channel,</li>"]
    #[doc = "<li>Returning the samples per channel matches the <code>libopus</code> API"]
    #[doc = "as closely as we're able,</li>"]
    #[doc = "<li>Returning the total number of values instead of samples per channel"]
    #[doc = "would mean the caller would need a division to compute the samples per"]
    #[doc = "channel, and might worry about the possibility of getting back samples"]
    #[doc = "for some channels and not others, and</li>"]
    #[doc = "<li>This approach is relatively fool-proof: if an application passes too"]
    #[doc = "small a value to \\a _buf_size, they will simply get fewer samples back,"]
    #[doc = "and if they assume the return value is the total number of values, then"]
    #[doc = "they will simply read too few (rather than reading too many and going"]
    #[doc = "off the end of the buffer).</li>"]
    #[doc = "</ol>"]
    #[doc = "\\param      _of       The \\c OggOpusFile from which to read."]
    #[doc = "\\param[out] _pcm      A buffer in which to store the output PCM samples as"]
    #[doc = "signed floats at 48&nbsp;kHz with a nominal range of"]
    #[doc = "<code>[-1.0,1.0]</code>."]
    #[doc = "Multiple channels are interleaved using the"]
    #[doc = "<a href=\"http://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-800004.3.9\">Vorbis"]
    #[doc = "channel ordering</a>."]
    #[doc = "This must have room for at least \\a _buf_size floats."]
    #[doc = "\\param      _buf_size The number of floats that can be stored in \\a _pcm."]
    #[doc = "It is recommended that this be large enough for at"]
    #[doc = "least 120 ms of data at 48 kHz per channel (5760"]
    #[doc = "samples per channel)."]
    #[doc = "Smaller buffers will simply return less data, possibly"]
    #[doc = "consuming more memory to buffer the data internally."]
    #[doc = "If less than \\a _buf_size values are returned,"]
    #[doc = "<tt>libopusfile</tt> makes no guarantee that the"]
    #[doc = "remaining data in \\a _pcm will be unmodified."]
    #[doc = "\\param[out] _li       The index of the link this data was decoded from."]
    #[doc = "You may pass <code>NULL</code> if you do not need this"]
    #[doc = "information."]
    #[doc = "If this function fails (returning a negative value),"]
    #[doc = "this parameter is left unset."]
    #[doc = "\\return The number of samples read per channel on success, or a negative"]
    #[doc = "value on failure."]
    #[doc = "The channel count can be retrieved on success by calling"]
    #[doc = "<code>op_head(_of,*_li)</code>."]
    #[doc = "The number of samples returned may be 0 if the buffer was too small"]
    #[doc = "to store even a single sample for all channels, or if end-of-file"]
    #[doc = "was reached."]
    #[doc = "The list of possible failure codes follows."]
    #[doc = "Most of them can only be returned by unseekable, chained streams"]
    #[doc = "that encounter a new link."]
    #[doc = "\\retval #OP_HOLE          There was a hole in the data, and some samples"]
    #[doc = "may have been skipped."]
    #[doc = "Call this function again to continue decoding"]
    #[doc = "past the hole."]
    #[doc = "\\retval #OP_EREAD         An underlying read operation failed."]
    #[doc = "This may signal a truncation attack from an"]
    #[doc = "<https:> source."]
    #[doc = "\\retval #OP_EFAULT        An internal memory allocation failed."]
    #[doc = "\\retval #OP_EIMPL         An unseekable stream encountered a new link that"]
    #[doc = "used a feature that is not implemented, such as"]
    #[doc = "an unsupported channel family."]
    #[doc = "\\retval #OP_EINVAL        The stream was only partially open."]
    #[doc = "\\retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that"]
    #[doc = "did not have any logical Opus streams in it."]
    #[doc = "\\retval #OP_EBADHEADER    An unseekable stream encountered a new link with a"]
    #[doc = "required header packet that was not properly"]
    #[doc = "formatted, contained illegal values, or was"]
    #[doc = "missing altogether."]
    #[doc = "\\retval #OP_EVERSION      An unseekable stream encountered a new link with"]
    #[doc = "an ID header that contained an unrecognized"]
    #[doc = "version number."]
    #[doc = "\\retval #OP_EBADPACKET    Failed to properly decode the next packet."]
    #[doc = "\\retval #OP_EBADLINK      We failed to find data we had seen before."]
    #[doc = "\\retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with"]
    #[doc = "a starting timestamp that failed basic validity"]
    #[doc = "checks."]
    pub fn op_read_float(
        _of: *mut OggOpusFile,
        _pcm: *mut f32,
        _buf_size: ::std::os::raw::c_int,
        _li: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Reads more samples from the stream and downmixes to stereo, if necessary."]
    #[doc = "This function is intended for simple players that want a uniform output"]
    #[doc = "format, even if the channel count changes between links in a chained"]
    #[doc = "stream."]
    #[doc = "\\note \\a _buf_size indicates the total number of values that can be stored"]
    #[doc = "in \\a _pcm, while the return value is the number of samples <em>per"]
    #[doc = "channel</em>, even though the channel count is known, for consistency with"]
    #[doc = "op_read()."]
    #[doc = "\\param      _of       The \\c OggOpusFile from which to read."]
    #[doc = "\\param[out] _pcm      A buffer in which to store the output PCM samples, as"]
    #[doc = "signed native-endian 16-bit values at 48&nbsp;kHz"]
    #[doc = "with a nominal range of <code>[-32768,32767)</code>."]
    #[doc = "The left and right channels are interleaved in the"]
    #[doc = "buffer."]
    #[doc = "This must have room for at least \\a _buf_size values."]
    #[doc = "\\param      _buf_size The number of values that can be stored in \\a _pcm."]
    #[doc = "It is recommended that this be large enough for at"]
    #[doc = "least 120 ms of data at 48 kHz per channel (11520"]
    #[doc = "values total)."]
    #[doc = "Smaller buffers will simply return less data, possibly"]
    #[doc = "consuming more memory to buffer the data internally."]
    #[doc = "If less than \\a _buf_size values are returned,"]
    #[doc = "<tt>libopusfile</tt> makes no guarantee that the"]
    #[doc = "remaining data in \\a _pcm will be unmodified."]
    #[doc = "\\return The number of samples read per channel on success, or a negative"]
    #[doc = "value on failure."]
    #[doc = "The number of samples returned may be 0 if the buffer was too small"]
    #[doc = "to store even a single sample for both channels, or if end-of-file"]
    #[doc = "was reached."]
    #[doc = "The list of possible failure codes follows."]
    #[doc = "Most of them can only be returned by unseekable, chained streams"]
    #[doc = "that encounter a new link."]
    #[doc = "\\retval #OP_HOLE          There was a hole in the data, and some samples"]
    #[doc = "may have been skipped."]
    #[doc = "Call this function again to continue decoding"]
    #[doc = "past the hole."]
    #[doc = "\\retval #OP_EREAD         An underlying read operation failed."]
    #[doc = "This may signal a truncation attack from an"]
    #[doc = "<https:> source."]
    #[doc = "\\retval #OP_EFAULT        An internal memory allocation failed."]
    #[doc = "\\retval #OP_EIMPL         An unseekable stream encountered a new link that"]
    #[doc = "used a feature that is not implemented, such as"]
    #[doc = "an unsupported channel family."]
    #[doc = "\\retval #OP_EINVAL        The stream was only partially open."]
    #[doc = "\\retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that"]
    #[doc = "did not have any logical Opus streams in it."]
    #[doc = "\\retval #OP_EBADHEADER    An unseekable stream encountered a new link with a"]
    #[doc = "required header packet that was not properly"]
    #[doc = "formatted, contained illegal values, or was"]
    #[doc = "missing altogether."]
    #[doc = "\\retval #OP_EVERSION      An unseekable stream encountered a new link with"]
    #[doc = "an ID header that contained an unrecognized"]
    #[doc = "version number."]
    #[doc = "\\retval #OP_EBADPACKET    Failed to properly decode the next packet."]
    #[doc = "\\retval #OP_EBADLINK      We failed to find data we had seen before."]
    #[doc = "\\retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with"]
    #[doc = "a starting timestamp that failed basic validity"]
    #[doc = "checks."]
    pub fn op_read_stereo(
        _of: *mut OggOpusFile,
        _pcm: *mut opus_int16,
        _buf_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Reads more samples from the stream and downmixes to stereo, if necessary."]
    #[doc = "This function is intended for simple players that want a uniform output"]
    #[doc = "format, even if the channel count changes between links in a chained"]
    #[doc = "stream."]
    #[doc = "\\note \\a _buf_size indicates the total number of values that can be stored"]
    #[doc = "in \\a _pcm, while the return value is the number of samples <em>per"]
    #[doc = "channel</em>, even though the channel count is known, for consistency with"]
    #[doc = "op_read_float()."]
    #[doc = "\\param      _of       The \\c OggOpusFile from which to read."]
    #[doc = "\\param[out] _pcm      A buffer in which to store the output PCM samples, as"]
    #[doc = "signed floats at 48&nbsp;kHz with a nominal range of"]
    #[doc = "<code>[-1.0,1.0]</code>."]
    #[doc = "The left and right channels are interleaved in the"]
    #[doc = "buffer."]
    #[doc = "This must have room for at least \\a _buf_size values."]
    #[doc = "\\param      _buf_size The number of values that can be stored in \\a _pcm."]
    #[doc = "It is recommended that this be large enough for at"]
    #[doc = "least 120 ms of data at 48 kHz per channel (11520"]
    #[doc = "values total)."]
    #[doc = "Smaller buffers will simply return less data, possibly"]
    #[doc = "consuming more memory to buffer the data internally."]
    #[doc = "If less than \\a _buf_size values are returned,"]
    #[doc = "<tt>libopusfile</tt> makes no guarantee that the"]
    #[doc = "remaining data in \\a _pcm will be unmodified."]
    #[doc = "\\return The number of samples read per channel on success, or a negative"]
    #[doc = "value on failure."]
    #[doc = "The number of samples returned may be 0 if the buffer was too small"]
    #[doc = "to store even a single sample for both channels, or if end-of-file"]
    #[doc = "was reached."]
    #[doc = "The list of possible failure codes follows."]
    #[doc = "Most of them can only be returned by unseekable, chained streams"]
    #[doc = "that encounter a new link."]
    #[doc = "\\retval #OP_HOLE          There was a hole in the data, and some samples"]
    #[doc = "may have been skipped."]
    #[doc = "Call this function again to continue decoding"]
    #[doc = "past the hole."]
    #[doc = "\\retval #OP_EREAD         An underlying read operation failed."]
    #[doc = "This may signal a truncation attack from an"]
    #[doc = "<https:> source."]
    #[doc = "\\retval #OP_EFAULT        An internal memory allocation failed."]
    #[doc = "\\retval #OP_EIMPL         An unseekable stream encountered a new link that"]
    #[doc = "used a feature that is not implemented, such as"]
    #[doc = "an unsupported channel family."]
    #[doc = "\\retval #OP_EINVAL        The stream was only partially open."]
    #[doc = "\\retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that"]
    #[doc = "that did not have any logical Opus streams in it."]
    #[doc = "\\retval #OP_EBADHEADER    An unseekable stream encountered a new link with a"]
    #[doc = "required header packet that was not properly"]
    #[doc = "formatted, contained illegal values, or was"]
    #[doc = "missing altogether."]
    #[doc = "\\retval #OP_EVERSION      An unseekable stream encountered a new link with"]
    #[doc = "an ID header that contained an unrecognized"]
    #[doc = "version number."]
    #[doc = "\\retval #OP_EBADPACKET    Failed to properly decode the next packet."]
    #[doc = "\\retval #OP_EBADLINK      We failed to find data we had seen before."]
    #[doc = "\\retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with"]
    #[doc = "a starting timestamp that failed basic validity"]
    #[doc = "checks."]
    pub fn op_read_float_stereo(
        _of: *mut OggOpusFile,
        _pcm: *mut f32,
        _buf_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
